# Техническое задание: Invite Service

## Введение

Invite Service – новый микросервис в составе SaaS-продукта для массовых рассылок и приглашений пользователей. Он интегрируется в уже существующую микросервисную архитектуру, включающую **integration-service** (управление подключенными аккаунтами) и **parsing-service** (сбор/парсинг аудитории). Данный сервис предназначен для автоматизированной отправки инвайтов (подписки пользователей в телеграм паблик/группу без учатия пользователя) и сообщений в мессенджерах (с начальной поддержкой Telegram и перспективой расширения на Instagram и WhatsApp) с учетом ограничений платформ и требований по масштабируемости.

**Цели Invite Service:** обеспечить безопасную и эффективную подписку и рассылку сообщений выбранной аудитории, используя ранее подключенные аккаунты пользователей, с соблюдением антиспам-лимитов платформ. Сервис должен предоставлять удобные механизмы управления рассылками (приоритезация, пауза/возобновление, отмена) и прозрачную статистику выполнения.

## Функциональные требования

Основные функции и требования к Invite Service:

- **Поддержка нескольких платформ:** на первом этапе сервис работает с Telegram; архитектура должна предусматривать лёгкое добавление поддержки Instagram и WhatsApp в будущем. Реализация должна быть мультиплатформенной, с единым интерфейсом (паттерн Strategy) для разных мессенджеров.
    
- **Использование подключенных аккаунтов:** сервис задействует аккаунты, подключенные через **integration-service**. Доступ к аккаунтам осуществляется посредством предоставленных учетных данных. Invite Service не хранит и не запрашивает пароли/сессии напрямую, а запрашивает их через API gateway у integration-service, обеспечивая безопасное получение ключей.
    
- **Импорт базы пользователей:** список целевых пользователей для рассылки может поступать из **parsing-service** (результаты парсинга аудитории) или загружаться пользователем вручную (в форматах CSV, Excel, JSON). Сервис должен поддерживать парсинг импортируемых файлов, сопоставление полей (напр. username, ID, телефон) и сохранение этой базы для последующей обработки.
    
- **Действия рассылки:** Invite Service должен уметь автоматически выполнять ряд действий над каждым пользователем базы:
    
    - Добавление пользователя в **контакты** (для платформ, где это применимо, напр. в Telegram по username или номеру телефона) – это требуется для добавления пользователя в паблик/группу, а также может потребоваться, чтобы снять ограничения на отправку сообщения незнакомому адресату.
        
    - **Приглашение в группу или канал** – если целевой аккаунт является администратором группы/канала с правами приглашать участников, сервис должен уметь добавлять пользователей из базы в эту группу/канал (инвайт).
    
    - Перед тем как задача будет запущена и после того как пользователь добавил ссылку на группу/канал, сервис должен уметь проверять является ли телеграм аккаунт администратором группы/канала, и если не является - отмечать его соответствующей меткой.
        
    - **Отправка личных сообщений** – для тех пользователей, кого **нельзя пригласить напрямую** (например, из-за настроек приватности «Приглашать в чаты могут только мои контакты»), сервис может высылать персональное сообщение (например, с приглашением или необходимой информацией), если это установлено в настройках на фронте.
        
- **Автоматическая скорость рассылки:** система должна **автоматически определять допустимую скорость** отправки инвайтов/сообщений. Скорость зависит от:
    
    - Количества задействованных аккаунтов (чем больше аккаунтов, тем больше суммарный безопасный throughput).
        
    - Объема задачи (число пользователей в базе – для больших списков может потребоваться растянуть рассылку по времени).
        
    - Текущего статуса аккаунтов (если некоторые аккаунты уже под ограничениями или блокированы, нагрузка должна перераспределяться на остальные).  
        При старте задачи Invite Service рассчитывает планируемый **темп отправки** (сообщений/приглашений в минуту) таким образом, чтобы не превышать индивидуальные лимиты каждого аккаунта и платформы. Например, в Telegram не рекомендуется отправлять более ~40 исходящих личных сообщений в сутки с одного аккаунта. Сервис должен учитывать такие ограничения и равномерно распределять пользователей между аккаунтами.
        
- **Антифлуд и адаптивное замедление:** в процессе рассылки Invite Service отслеживает ошибки и реакцию платформ (например, ошибки **Flood/Spam**). При выявлении признаков флуда или блокировки:
    
    - Аккаунт, получивший предупреждение (типа _Flood Wait_ или временный бан), помечается и отправляется на «отдых» – т.е. временно не используется для новых приглашений/сообщений. Например, Telegram может временно блокировать аккаунт после ~40 исходящих сообщений, особенно если они однотипные или получены жалобы.. В таком случае сервис ставит аккаунт на паузу (длительность – согласно требуемому времени ожидания от API или фиксированному интервалу).
        
    - Нагрузка (рассылка оставшимся получателям) перераспределяется на другие аккаунты, если таковые доступны и не исчерпали лимиты. Таким образом поддерживается прогресс задачи, хоть и с уменьшенной скоростью.
    - Если все аккаунты недоступны или находятся на "отдыхе", то задача ставится на паузу, до момента, когда появятся отдохнувшие или добавятся новые аккаунты, и стартует автоматически
        
    - Гибкий механизм должен уметь **динамически снижать скорость** отправки при первых признаках возможного флуда: напр. увеличивать паузы между сообщениями, уменьшать количество одновременных приглашений, чтобы избежать эскалации до блокировки. Если ситуация нормализуется (аккаунты «отдохнули» и снова могут отправлять), скорость может быть частично повышена, но не выше безопасных порогов.
        
- **Управление заданиями:** Invite Service должен поддерживать постановку нескольких задач (кампаний) с **приоритетами**. Необходимо реализовать очереди задач с приоритетным обслуживанием: задачи с более высоким приоритетом запускаются раньше или получают больше ресурсов. Также должна быть возможность **поставить задачу на паузу**, **возобновить** ее выполнение, либо **отменить** (прекратить незавершенную рассылку). Эти функции аналогичны реализованным в parsing-service, поэтому можно использовать схожие подходы (например, хранение статуса задачи в БД и проверка статуса воркерами перед обработкой каждого нового элемента).
    
- **Статистика и прозрачность:** пользователю (и администратору) должна быть доступна подробная статистика по каждой рассылке в реальном времени и по завершении:
    
    - Сколько пользователей **обработано** из базы, в том числе разбивка по действиям: сколько добавлено в контакты, сколько приглашено в группы, скольким отправлено личных сообщений.
        
    - Статус каждого задействованного аккаунта: работает, в паузе (cooldown), временно заблокирован, полностью заблокирован и т.п.
        
    - Сколько пользователей **осталось** в очереди необработанными.
        
    - Текущая скорость выполнения (например, X действий в минуту) и прогнозируемое оставшееся время.
        
    - По завершении – итоговый отчет с результатами: сколько успешно приглашено, сколько не удалось (с указанием причин, например, N пользователей – закрытый профиль/невозможно пригласить, M – отправлено личное сообщение вместо инвайта и т.д.).
        
- **Соответствие корпоративным стандартам:** архитектура Invite Service должна соответствовать существующим практикам продукта:
    
    - Реализация backend API в стиле **FastAPI** (Python) – аналогично parsing-service, с RESTful эндпойнтами для управления задачами и получения статуса.
        
    - Использование **модели Platform Adapter (паттерн Strategy)** для поддержки разных платформ: единый интерфейс (абстракция) для операций рассылки (например, метод `send_invite(user)` или `send_message(user)`), с раздельными реализациями для Telegram, Instagram, WhatsApp. Это обеспечит расширяемость – добавление новой платформы требует реализации соответствующей стратегии, не затрагивая ядро сервиса.
        
    - Интеграция с **очередью задач Celery** для масштабирования и асинхронного выполнения. Тяжелые операции (массовые отправки) должны выполняться воркерами Celery в фоновом режиме, позволяя масштабировать количество воркеров при росте нагрузки.
        
    - Соблюдение **best practices** соответствующих платформ по рассылкам: учитывание антифлуд ограничений, лимитов API, политик против спама. Например, выдерживание пауз между сообщениями, ограничения суточных отправлений, использование нескольких аккаунтов для масштабирования без нарушения лимитов и т.п. (подробнее в разделе лимитов ниже).
        
    - Хранение секретных данных (ключей API, токенов, сессий) в **Vault** – сервис должен получать необходимые учетные данные через интеграцию с Vault (или через integration-service, который сам абстрагирует доступ к Vault). Таким образом, ни пароли, ни session-файлы не хранятся в открытом виде в коде или конфигурациях Invite Service.
        
    - Обеспечение безопасности: авторизация запросов через JWT (совместимо с общей системой auth продукта), изоляция данных разных пользователей (multi-tenant). Это означает, что сервис, получив JWT-токен пользователя, должен валидировать его, определить соответствующего пользователя системы и выполнять операции (например, рассылку) **только от имени аккаунтов данного пользователя**. Пользователь не должен иметь доступ к аккаунтам и данным других пользователей. Все данные задач (списки получателей, статистика) изолируются по user_id, аналогично подходам в parsing-service.
        

## Бизнес-логика Invite Service

### Работа с аккаунтами и интеграция с integration-service

Invite Service не управляет напрямую процессом подключения аккаунтов – этим занимается существующий integration-service. Предполагается, что к моменту создания рассылки пользователь уже подключил необходимые аккаунты (Telegram, а в перспективе Instagram/WhatsApp) через integration-service, и эти учетные данные безопасно хранятся (в Vault или в базе integration-service).

При создании новой задачи Invite Service запрашивает у integration-service список доступных аккаунтов текущего пользователя для указанной платформы. Каждый аккаунт имеет необходимые credentials:

- **Telegram:** session data (файл или строка сессии Telethon/Pyrogram), api_id и api_hash приложения. Возможно, integration-service вернет не сами сессионные данные, а ссылку на хранение в Vault, и Invite Service воспользуется ею для загрузки.
    
- **Instagram:** токен доступа к Instagram Graph API для бизнес-аккаунта, либо куки/сессия, если используется неофициальный метод. (При реализации поддержки IG нужно учесть, что официально Instagram API ограничивает возможность отправки сообщений: требуется бизнес-аккаунт и получатель должен ранее взаимодействовать, либо придется использовать эмулирование клиента – это за рамками MVP, но архитектура должна позволить добавить такой адаптер.)
    
- **WhatsApp:** либо креденшлы для Business API (идентификатор номера, токен доступа к Cloud API), либо данные для подключения через сторонний сервис (если использовать Web-сессию). Рекомендуется планировать официальную интеграцию через WhatsApp Business API для надежности и масштабируемости.
    

Получив учетные данные, Invite Service инициализирует для каждого аккаунта **клиента платформы** (например, TelegramClient через Telethon/Pyrogram, клиент WhatsApp API, и т.д.). Это реализовано внутри соответствующего адаптера платформы. Клиенты могут переиспользоваться между задачами, но важно управлять их состоянием: например, Telegram-клиент должен быть подключен (логин выполнен) до начала рассылки. При старте задачи можно параллельно запустить и залогинить клиенты всех аккаунтов, чтобы не тратить время в процессе отправки.


### Импорт базы получателей

Пользователь может предоставить список получателей одним из способов:

- **Через parsing-service:** пользователь выбирает ранее собранную базу (например, список пользователей, спарсенных из определенного Telegram-чата или из Instagram-аудитории). Предполагается, что parsing-service сохранил результат (список user_id, usernames или телефонов) и может предоставить его по запросу. Invite Service должен уметь вызвать API parsing-service (например, `GET /parsed_data/{id}`) чтобы получить список контактов. Формат данных – JSON либо CSV.
    
- **Файл вручную:** пользователь загружает файл (CSV, XLSX, JSON) через frontend, который отправляется на Invite Service. Сервис парсит файл – определяет колонки (например: `username`, `phone_number`, `user_id` и т.п.) либо получает от пользователя настройки сопоставления полей. Нужно поддержать типичные случаи: CSV с одной колонкой (список телефонов или @username), CSV с несколькими колонками (например, имя, телефон), Excel таблицу, JSON (список объектов). При импорте Invite Service валидирует и нормализует данные – например, убрать дубликаты, отфильтровать явный мусор (пустые строки).
    

Для Telegram допустимы идентификаторы пользователей или username (если аккаунт публичный) или телефон (если знаем номер). Для Instagram – обычно username или внутренний ID (при использовании API). Для WhatsApp – телефон в международном формате. Внутри задачи, для каждого получателя должна быть возможность получить уникальный идентификатор платформы, необходимый для отправки (например, Telethon требует либо user_id, либо телефон для добавления контакта).

После импорта база пользователей хранится временно (например, в БД Invite Service) с привязкой к задаче. Можно реализовать таблицу `invite_targets` со схемой: `task_id`, `platform`, `user_identifier`, `status` и пр. Однако для экономии памяти при очень больших списках можно обойтись без хранения всего списка в памяти – вместо этого итерировать по входному файлу/потоку. Но для отслеживания прогресса удобнее сохранить их. Выбирается компромисс: например, хранить в БД только агрегированные счетчики, а сами данные либо в памяти воркера, либо в временном файле. В данном ТЗ предполагается, что объемы позволяют хранение списка (например, десятки-сотни тысяч контактов).

### Алгоритм рассылки (инвайты и сообщения)

После инициализации аккаунтов и получения базы начинается выполнение задачи рассылки. Логика для **каждого получателя** может быть описана следующим псевдокодом (для случая Telegram, аналогично адаптируется для др. платформ):

sql



`for each user in recipients_list:     for each account in available_accounts (round-robin or assigned):         if account.is_active():             try:                 if platform == Telegram:                     performTelegramInviteOrMessage(account, user)                 elif platform == Instagram:                     performInstagramInviteOrMessage(account, user)                 ...                 mark user as processed (invited or messaged)                 break out of account loop for this user (user handled)             except RateLimitException e:                 account.markCooldown(e.retry_after)                 continue with next account for same user             except PrivacyRestrictionException:                 # e.g., user cannot be added to group                 if not user.message_sent:                     sendMessageInstead(account, user)                 mark user as processed (messaged)                 break             except AccountBlockedException:                 account.markBlocked()                 continue with next account (this account can't be used)             ...     if not processed:         # all accounts failed (unlikely if some blocked, others tried)         mark user as failed`

Объяснение:

- Пользователи могут распределяться между аккаунтами либо **равномерно (round-robin)**, либо по другой стратегии. В простейшем случае – равномерно: аккаунты циклически берут по одному получателю. Это эффективно распараллелит отправку и распределит нагрузку. Однако если аккаунтов намного меньше чем получателей, лучше разделить список заранее на чанки по числу аккаунтов. Например, если 4 аккаунта и 1000 получателей, каждому аккаунту дать ~250 контактов. Это предотвратит ситуацию, когда один аккаунт получает подряд слишком много пользователей без пауз. Но если телеграм аккаунт ушёл в блок, то распределить его контакты между оставшимися  телеграм аккаунтами, и наоборот, если вышел из блока, то вернуть ему равноценное количество оставшихся контактов. 
    
- **Отправка приглашения:** для Telegram, если у нас есть права админа в целевой группе/канале, вызывается метод API для добавления пользователя. Например, Telethon: `InviteToChannelRequest` или `AddChatUser`. Если приглашение успешно – пользователь считается обработанным (и увеличивается счетчик «приглашено»).
    
- Если произошла ошибка _PrivacyRestriction_ (пользователь запретил приглашать себя в группы), сервис должен выполнить альтернативное действие – **отправить личное сообщение** этому пользователю, в том случае если это установлено в настройках на фронте. Перед отправкой сообщения может потребоваться добавить пользователя в контакты (Telegram API позволяет отправить сообщение незнакомому по username без добавления, но по номеру телефона – только добавив контакт). Поэтому:
    
    - Если известен username: можно сразу отправлять сообщение через `sendMessage(username, текст)`.
        
    - Если есть только телефон: сперва выполнить `ImportContactsRequest` (добавить в список контактов аккаунта), а затем отправить сообщение в личку.  
        В сообщении может быть, например, текст приглашения и ссылка-приглашение на группу/канал. Этот кейс увеличивает счетчик «отправлено сообщений».
        
- **Отправка личного сообщения вместо инвайта:** должна помечаться в статистике отдельно, т.к. цель (приглашение) достигнута не напрямую, а через сообщение.
    
- После обработки каждого пользователя выполняются **необходимые паузы** (задержки) перед переходом к следующему, чтобы не превышать частотные лимиты. Например, для Telegram рекомендуемая пауза между последовательными действиями ~**10-15 секунд**, чтобы не триггерить антифлуд. Для Instagram Direct API – рекомендуется даже больше (в источниках упоминается 8-10 минут между исходящими сообщениями для новых аккаунтов, хотя при большом количестве аккаунтов можно чередовать их).
    
- **Обработка исключений и ошибок:**
    
    - _RateLimit/FloodWait:_ если API вернул ошибку, указывающую на превышение лимита (например, `FloodWaitError` с параметром времени ожидания или аналогичное исключение), Invite Service должен:
        
        - пометить данный аккаунт как временно приостановленный (**cooldown**), сохранив время, на которое нужно ждать (если известно). Например, Telethon дает `FloodWaitError: A wait of 600 seconds is required` – сервис ставит аккаунт на паузу 10 минут.
            
        - не бросать всю задачу, а попробовать использовать другой аккаунт для этого же пользователя (если возможно). В алгоритме выше это достигается `continue` на следующий аккаунт. Если же альтернативный аккаунт не доступен, задача для этого пользователя отложится.
            
        - запланировать повторную активацию аккаунта после cooldown (можно через Celery ETA-задачу или внутр. таймер). Когда время пройдет, аккаунт снова помечается активным и может продолжить с следующими неразосланными получателями.
            
    - _AccountBlockedException:_ если при попытке отправки выявляется, что аккаунт полностью заблокирован (например, Telegram возвращает `PeerFloodError` без таймаута, или `AuthKeyUnregistered` – сессия аннулирована, или integration-service пометил аккаунт как «ban»), то:
        
        - Немедленно пометить аккаунт как **заблокированный**; в статистике аккаунту присваивается статус "забанен". Он более не используется в рамках текущей (и, возможно, следующих) задач.
            
        - Оставшихся получателей, назначенных этому аккаунту, перераспределить на другие аккаунты, если возможно. Если нет – оставшиеся получатели могут быть помечены как неразосланные либо задача завершается частично неуспешно (в отчете указать, что X пользователей не обработано из-за блокировки всех аккаунтов).
            
        - При блокировке аккаунта стоит также уведомить integration-service, чтобы тот обновил статус аккаунта в системе (вне рамок Invite Service).
            
    - _Другие ошибки:_ учитываются также ошибки отправки сообщения (например, пользователь удалил аккаунт, и запрос возвращает `UserDeactivated`; или для WhatsApp – ошибку от API если пользователь отписался). Такие случаи фиксируются, помечаются как «не доставлено по причине ...» но не останавливают всю рассылку.
        
- **Завершение задачи:** когда все пользователи обработаны (или помечены как не обработанные из-за ошибок), задача считается выполненной или завершенной (успешно или частично). Invite Service обновляет статус задачи (например, `DONE`, `DONE_WITH_ERRORS`, `CANCELLED` и т.д.) в своей базе. Пользователь может запросить итоговый отчет.
    

### Управление скоростью, лимиты и параллелизм

**Авто-определение скорости:** Перед началом рассылки Invite Service оценивает оптимальную скорость отправки. Она зависит от правил платформ:

- **Telegram:** согласно практике, с одного аккаунта безопасно рассылать порядка **40 сообщений в день** (если без ссылок) или ~**10 сообщений с ссылкой** (если в тексте есть URL)[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8). Приглашать в группы можно ~**50 пользователей в сутки** с аккаунта[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8). Рекомендуемый интервал между действиями 10+ секунд[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8). В сумме, это около 6-7 сообщений в час, чтобы не превышать 40 в день, либо чуть больше с паузами ночью. Если у нас N аккаунтов, теоретический суммарный максимум ≈ N*40 получателей в день (без ссылок). Однако если нужно ускорить, можно задействовать все аккаунты параллельно – например, 5 аккаунтов могут разослать ~200 сообщений/инвайтов в сутки без превышения лимитов.
    
- **Instagram:** значительно строже политика. Для нового Instagram-аккаунта лимит ~**20 исходящих сообщений в Direct в сутки**, для аккаунта возрастом до 6 мес – ~**40 сообщений/сутки**, для старого (6+ мес) – ~**50/сутки**[postium.ru](https://postium.ru/limity-instagram/#:~:text=%D0%94%D0%BB%D1%8F%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D0%B0%3A). Также категорически нельзя слать одно и то же сообщение десяткам пользователей – это будет воспринято как спам[postium.ru](https://postium.ru/limity-instagram/#:~:text=,%D1%81%D1%83%D1%82%D0%BA%D0%B8). Паузу между отправками Instagram рекомендует большую – **не менее 8-10 минут между сообщениями в Direct**[postium.ru](https://postium.ru/limity-instagram/#:~:text=%2A%20%D0%BF%D0%B0%D1%83%D0%B7%D1%8B%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D0%BB%D0%B0%D0%B9%D0%BA%D0%B0%D0%BC%D0%B8%3A%2025,10%20%D0%BC%D0%B8%D0%BD%D1%83%D1%82). Поэтому Invite Service для Instagram может изначально ставить большую задержку (например, 10 минут) на каждый аккаунт. При наличии нескольких аккаунтов рассылка может идти параллельно, но каждый аккаунт не должен превышать ~5 сообщений/час.
    
- **WhatsApp:** если использовать **официальный WhatsApp Business API**, то существуют **уровни (tiers) ограничений** на количество уникальных пользователей, которым можно написать за сутки. Стартовый уровень обычно ~**250 уникальных контактов/сутки**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Tier%201). После подтверждения бизнеса и хорошего качества переписки, лимит повышается до **1000 контактов/сутки**, далее до **10 000** и **100 000**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Allows%20you%20to%20have%20250,hour%20period)[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Allows%20you%20to%20have%2010%2C000,hour%20period). Эти лимиты применимы к бизнес-инициированным сообщениям (шаблонным). При использовании Invite Service с официальным API нужно соблюдать эти ограничения – сервис должен отслеживать, сколько уникальных получателей было контактов за последние 24 часа по каждому номеру. Через API Meta можно получать текущий tier и % использования лимита. Скорость отправки через Cloud API высока (до **80 сообщений в секунду** на номер по умолчанию) – т.е. throughput не проблема[developers.facebook.com](https://developers.facebook.com/docs/whatsapp/cloud-api/overview/#:~:text=Overview%20,1%2C000%20mps%20by%20automatic%20upgrade), важнее не выйти за суточный лимит и поддерживать высокий **Quality rating**.
    
    Планируется поддержка рассылки через **обычные WhatsApp-клиенты** , Invite Service должен ограничивать количество новых чатов в WhatsApp. Точных официальных цифр нет (WhatsApp активно банит за массовый разовый спам), но по практике не следует писать более ~50-100 незнакомым контактам в день с одного номера, и обязательно рассылка должна быть **разбита на небольшие партии с большими паузами**. Например, отправлять не более ~10 сообщений подряд, потом ждать несколько часов, и т.д. Кроме того, WhatsApp ограничивает _разовое_ распределение сообщений: например, функция Broadcast Lists позволяет отправить одному списку максимум 256 контактов, и только если они сохранили ваш номер. Invite Service при поддержке WA должен в идеале пользоваться официальным API или тщательно эмулировать поведение обычного пользователя (не мгновенно множество сообщений, а медленно, с вариациями, и реагировать на признаки блокировки).
    

**Распределение нагрузки между аккаунтами:** Сервис должен стремиться параллелить отправку на разные аккаунты, но **не посылать с одного аккаунта несколько сообщений одновременно**. Для этого целесообразно запустить отдельные воркеры/задачи Celery на каждый аккаунт: например, при старте рассылки создаются под-задачи для каждого аккаунта, каждая из которых обрабатывает свою часть списка с соответствующими задержками. Так достигается одновременная работа (N аккаунтов – N потоков рассылки).

**Приоритизация задач:** Если одновременно запущены несколько кампаний (задач рассылки), Invite Service должен учитывать их приоритет. Возможна реализация через несколько очередей Celery (например, high-priority и normal) либо за счет атрибута приоритета задач Celery (нужна поддержка брокера, RabbitMQ поддерживает priority). Высокоприоритетные задачи помещаются в соответствующую очередь и воркеры обрабатывают их в первую очередь. Также, внутри задачи с высоким приоритетом, можно выделять аккаунты специально под нее. Например, если у пользователя A задача высокоприоритетная, а у пользователя B – низкая, и они теоретически могли бы использовать одни и те же аккаунты, сервис может решить все аккаунты пользователя пустить на высокую задачу, а низкую притормозить. Однако, так как аккаунты привязаны к пользователям, межпользовательского ресурса тут нет – приоритет скорее важен, когда один пользователь запускает несколько задач (например, «очередь рассылок»). В таком случае Invite Service должен выполнять их последовательно или параллельно в зависимости от приоритета.

**Пауза, возобновление, отмена:**

- **Пауза:** реализуется путем установки статуса задачи “paused” в базе. Воркеры, обрабатывающие рассылку, должны периодически проверять статус (например, каждые N пользователей или каждый цикл отправки). Если статус стал “paused”, воркер должен прервать обработку дальнейших получателей и сохраниться. Текущее выполнение можно безопасно прервать после окончания обработки текущего пользователя, чтобы не оставлять половинчатое состояние. Данные о прогрессе (индекс текущего получателя, либо список оставшихся) сохраняются. Альтернативный подход – не запускать всю задачу разом, а выдавать задания порциями (batch). Тогда пауза может означать просто не выдавать новую порцию. В Celery можно реализовать паузу, отправив работникам управляющий сигнал, но надежнее контролировать через общую БД.
    
- **Возобновление:** переводит статус обратно в “running”. Если использовались порции – scheduler начнет заново выдавать задания. Если воркер прерывался – запускается новый воркер, который продолжает с места остановки. Например, зная последний обработанный индекс.
    
- **Отмена:** устанавливает статус “cancelled”. Аналогично паузе, воркеры останавливаются (либо прекращают брать новые задания). Все необработанные получатели помечаются как отмененные, и задача завершается. В отчете будет указано, сколько успели обработать до отмены.
    
- Эти операции (пауза/отмена) должны быть **идемпотентными** и быстрыми: желательно, чтобы пауза срабатывала почти мгновенно. Реализовать мгновенную паузу непросто, если воркеры заняты обработкой – но можно, например, отправлять тестовый исключение внутрь задачи (через механизм Celery revoke/terminate). Однако, чтобы избежать некорректных промежуточных состояний, лучше дождаться завершения текущей итерации.
    

### Статистика и отчётность

Invite Service в реальном времени собирает статистику по задачам. Хранение статистики можно организовать в памяти (с периодическим сохранением в БД) или сразу в БД. Например, таблица `invite_task_stats` с колонками: `task_id`, `processed_count`, `invited_count`, `messaged_count`, `failed_count`, `per_account_status(json)`, `last_update_time` и т.д. Каждое обновление статистики (после обработки каждого пользователя или каждых 10 пользователей) воркер может писать обновленные значения. Для высокой нагрузки лучше не писать слишком часто – можно обновлять каждые X секунд.

Через API (эндпойнт, например, `GET /invite/{task_id}/status`) пользователь может получить:

- **Прогресс:** обработано M из N пользователей (% завершено).
    
- **Разбивка результатов:** приглашено (в группу) X пользователей, Y – отправлено личное сообщение вместо инвайта, Z – не удалось (ошибки).
    
- **Статусы аккаунтов:** напротив каждого аккаунта: сколько действий совершил, есть ли ошибки. Например, Account1: 20 приглашений (OK), Account2: 15 приглашений, 1 временный блок (ждет 1 час)[chatapp.online](https://chatapp.online/kz/help/telegram-personal-limits/#:~:text=,%D0%BD%D0%B0%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%B6%D0%B0%D0%BB%D0%BE%D0%B2%D0%B0%D0%BB%D0%B8%D1%81%D1%8C%20%E2%80%94%C2%A0%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0), Account3: заблокирован полностью после 5 приглашений.
    
- **Очередь:** сколько получателей осталось и ориентировочное время завершения при текущей скорости.
    
- **Текущая скорость:** например, “~5 сообщений/минуту суммарно” – это можно вычислять на основе последних нескольких минут активности.
    

По завершении задачи Invite Service готовит финальный **отчет**. Его можно хранить или генерировать по запросу (`GET /invite/{task_id}/report`). Отчет включает все вышеперечисленное, а также списки пользователей, которых не удалось обработать (с причиной), чтобы пользователь мог, например, выгрузить их и повторить попытку позже.

## Архитектура и дизайн системы

### Общий обзор

Invite Service будет развернут как отдельный микросервис (Docker-контейнер), со своим REST API (FastAPI) и фоновыми обработчиками (Celery). Компоненты:

- **FastAPI Web Server:** Обрабатывает входящие HTTP-запросы (от фронтенда или других сервисов). Предоставляет эндпойнты:
    
    - создание новой рассылки (`POST /invite` с параметрами: платформа, список или ссылка на базу, текст сообщения, и др.),
        
    - управление задачей (`POST /invite/{id}/pause`, `/resume`, `/cancel`),
        
    - получение статуса/результатов (`GET /invite/{id}/status` и `/report`).  
        Эти ручки проверяют JWT-токен, авторизуют пользователя, валидируют входные данные. После чего, например, при создании, создают запись задачи в БД, инициируют Celery-задачу на выполнение рассылки и возвращают пользователю ID задачи.
        
- **База данных (PostgreSQL):** Хранит данные о рассылках: таблица задач (task_id, пользователь, платформа, параметры, статус, приоритет, таймстампы), таблица получателей (может быть объемной, возможно, стоит хранить только в памяти, но для надёжности можно и в БД с отложенной очисткой), таблица аккаунтов (кеш подключенных аккаунтов пользователя, либо запрашивать каждый раз у integration-service – оптимальнее, возможно, при старте задачи закешировать). Также таблицы логов или результатов, по необходимости.
    
- **Integration-service API:** Invite Service взаимодействует с ним, например:
    
    - `GET /accounts?user_id=XXX&platform=telegram` – получить список учеток Telegram данного пользователя с их идентификаторами или сессионными данными (может быть урезанная инфа + ссылки на секреты).
        
    - Возможно, `POST /accounts/check` – чтобы обновлять статус аккаунта (например, пометить как заблокированный). Хотя это не ключевая функция Invite Service, но полезно уведомлять об обнаруженных баны.
        
- **Vault:** Хранилище секретов. Invite Service через специализированный клиент или через integration-service достает необходимые credentials. Например, имея от integration-service идентификатор сессии Telegram в Vault, Invite Service запрашивает у Vault расшифровку и получает данные для входа. В целях безопасности, эти данные хранятся только в оперативной памяти на время выполнения задачи; после завершения (или при длительной паузе) их следует очищать. Vault должен быть настроен так, чтобы у Invite Service были нужные роли доступа – только к секретам своих пользователей (в идеале, через токен, соответствующий пользователю).
    
- **Celery + брокер сообщений:** Используем Celery для фоновых задач. Брокер – RabbitMQ или Redis. Celery воркеры запускаются (может быть в том же контейнере или отдельно). Основная задача – обработка рассылки – реализуется как Celery task, например `run_invite_campaign(task_id)`. При запуске через API, FastAPI ставит эту задачу в очередь (`celery_app.send_task("run_invite_campaign", args=[task_id])`).
    
    - **Конкурентность:** можно настроить, например, число воркеров = число аккаунтов или иным образом. Каждая задача-кампания может порождать подзадачи: например, создаем по одной sub-task на аккаунт (`run_invite_for_account(task_id, account_id, subset_of_users)`). Тогда Celery сможет их выполнять параллельно. Альтернатива – внутри одной задачи запускать asyncio корутины (FastAPI позволяет), но с Celery лучше держать процессы отдельными.
        
    - **Очереди Celery:** можно настроить отдельные очереди по приоритетам. Например, `celery -Q high,normal`. Задачам назначается queue в зависимости от priority.
        
    - **Маршрутизация задач:** В Celery можно маршрутизировать задачи на определенные воркеры. Например, если мы хотим гарантировать, что один воркер обрабатывает только один аккаунт, можно запустить пул воркеров по числу аккаунтов, но это избыточно. Проще семафорами или внутри задачи контролировать использование аккаунта.
        
- **Компонент Platform Adapter:** это модуль (набор классов) внутри Invite Service, инкапсулирующий логику работы с конкретным мессенджером. Можно реализовать как классы `TelegramInviteStrategy`, `InstagramInviteStrategy`, `WhatsAppInviteStrategy`, реализующие общий интерфейс `InviteStrategy`. Пример методов: `login(account_credentials)`, `invite_to_group(account, user)` , `send_message(account, user, message)` и т.п. Invite Service (ядро) будет использовать эти методы, не вникая в детали API. Например:
    
    python
    
    КопироватьРедактировать
    
    `strategy = get_strategy(platform) strategy.login(account.cred) for user in users:     try:         strategy.invite_or_message(account, user, group=..., message_text=...)     except PlatformRateLimit as e:         ...`
    
    Внутри Telegram-стратегия использует Telethon/Pyrogram, Instagram-стратегия – Instagram Graph API (если доступно) или сторонний клиент, WhatsApp – либо HTTP запросы к Cloud API (для шаблонных сообщений) или использование низкоуровневой библиотеки для Web WhatsApp (если пойдут по неофициальному пути).
    
    При добавлении новой платформы – достаточно создать новую стратегию, реализовать все необходимые методы (с учетом лимитов платформы), и зарегистрировать ее в фабрике `get_strategy`. Общая логика Invite Service уже умеет распределять нагрузку, обрабатывать паузы, поэтому новая стратегия будет использоваться прозрачно.
    
- **Логирование и мониторинг** (подробно см. секцию "Мониторинг и логирование") – в архитектуре следует учесть, что все компоненты должны отправлять логи в централизованную систему (например, ELK). Также необходимы метрики (Prometheus), но об этом ниже.
    

Диаграмма взаимодействия компонентов (условно):

rust

КопироватьРедактировать

`Пользователь -> [API Gateway/Auth] -> FastAPI (Invite Service) ->      (JWT проверка) -> запрос к Integration-service (аккаунты) & Parsing-service (аудитория) ->          запись task в БД -> Celery task запуск ->              Celery воркеры -> Platform Adapters (вызывают Telegram/IG/WA API) ->                  внешние платформы (Telegram/Instagram/WhatsApp серверы)             |             -> обновление статуса в БД ->  FastAPI периодически читает статус -> по запросу отдает пользователю.`

### Масштабируемость и отказоустойчивость

Invite Service должен эффективно работать при увеличении нагрузки. Для этого:

- **Горизонтальное масштабирование воркеров:** добавить больше процессов Celery при росте числа одновременных рассылок. Данные о задачах в БД обеспечивают координацию. Важно, чтобы при масштабировании не возникало двухворкерной обработки одного и того же пользователя – этого можно избежать, если каждый task_id обрабатывается одним воркером или подзадачи чётко разделены по пользователям. Celery гарантирует, что одну задачу выполнит один воркер. Если разбиваем на подзадачи, нужно аккуратно формировать разделение пользователей, чтобы не было overlap.
    
- **Масштабирование по аккаунтам:** если у пользователя подключено много аккаунтов, мы потенциально можем ускорить рассылку. Но число аккаунтов тоже не бесконечно, к тому же часто ограничено. Однако, сервис может быть SaaS – на всю систему может быть большое число аккаунтов разных пользователей, которые могут одновременно слать рассылку. Это суммарно создаст большую нагрузку, в т.ч. на Telegram API. Нужно предусмотреть и **глобальные лимиты**: например, Telegram API ограничивает клиент примерно 30 запросов в секунду[chatapp.online](https://chatapp.online/kz/help/telegram-personal-limits/#:~:text=,%D0%BD%D0%B0%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%B6%D0%B0%D0%BB%D0%BE%D0%B2%D0%B0%D0%BB%D0%B8%D1%81%D1%8C%20%E2%80%94%C2%A0%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0). Если на одном воркере работает 10 аккаунтов, каждые слать по сообщению в 10 секунд (0.1 msg/s each), суммарно ~1 сообщение/с – далеко до 30, это ок. Но если мы масштабируем до 1000 аккаунтов (суммарно 100 msg/s), можем приблизиться к граничным значениям API. В таких случаях, можно либо увеличивать распределение на разные IP/proxy (Telegram зачастую не строго ограничивает по IP, но в Telegram Prime примере упоминают использование прокси для бесконечного масштабирования[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=%D1%82%D1%8B%D1%81%D1%8F%D1%87%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9%2C%20%D0%B5%D1%81%D0%BB%D0%B8%20%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE)). **Рекомендация:** для крупных развёртываний предусмотреть поддержку прокси-серверов или распределение запросов с разных узлов, чтобы избежать IP rate limit.
    
- **Vault и внешние сервисы**: должны быть кластеризованы или доступные с высокой готовностью, т.к. простой Vault или integration-service может остановить работу Invite Service (например, если при старте задачи не удается получить сессии аккаунтов). Нужно реализовать **кэширование** учетных данных на короткое время: после первого запроса их можно держать в памяти воркера, чтобы не обращаться к Vault перед каждой отправкой.
    
- **Отказ при ошибках Celery:** если воркер падает посреди выполнения, Celery может пометить задачу как проваленную. Необходимо, чтобы Invite Service умел корректно возобновлять задачу – например, поймав событие failure, помечать ее как «прерванная по ошибке» и предоставлять возможность рестарта. Также, для важных задач, можно включить механизм **ACK после выполнения блока**: разбить процесс рассылки на множество маленьких задач (например, 1 задача = отправить 1 сообщение). Тогда сбой затронет только одного получателя, а Celery restarts others. Но это может усложнить контроль последовательности и пауз, поэтому, балансируя, мы оставляем обработку списков в рамках задачи, но с периодическим сохранением прогресса.
    

## Примеры лимитов и допустимых скоростей

Ниже суммированы ориентировочные лимиты и рекомендации по скорости для поддерживаемых платформ, основанные на известных best practices:

- **Telegram:**
    
    - **Приглашения в группы/каналы:** порядка **50 инвайтов в сутки с аккаунта** – больше не позволит пригласить (Telegram ограничивает принудительное добавление ~200 людьми вообще, но на практике лучше не более 50 в день)[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8).
        
    - **Исходящие личные сообщения (без ссылок):** ~**40 сообщений в день** на аккаунт безопасно[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8). Если включать ссылки в сообщения – не более ~**10 в день** (Telegram более строго относится к сообщениям со ссылками)[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8).
    - Соответственно сервис должен проверять наличие ссылки в сообщении и устанавливать соответствующий лимит автоматически.
        
    - **Рассылка через пересылку/forward:** до ~20 сообщений в день (если контент пересылается)[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8).
        
    - **Частота запросов API:** не более ~30 сообщений в секунду на клиент в целом[chatapp.online](https://chatapp.online/kz/help/telegram-personal-limits/#:~:text=,%D0%BD%D0%B0%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%B6%D0%B0%D0%BB%D0%BE%D0%B2%D0%B0%D0%BB%D0%B8%D1%81%D1%8C%20%E2%80%94%C2%A0%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0) (обычно нас это не коснется, т.к. один аккаунт мы столько не выдаем).
        
    - **Паузы между сообщениями:** **10-15 секунд** между отправками и инвайтами[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=,%D0%BF%D0%B0%D1%83%D0%B7%D0%B0%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8%20%D0%B8%20%D0%B8%D0%BD%D0%B2%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8). Также рекомендуется **не повторять один и тот же текст** дословно много раз подряд – добавлять вариативность, обращения по имени, чтобы не выглядеть ботом[chatapp.online](https://chatapp.online/kz/help/telegram-personal-limits/#:~:text=,%D0%BD%D0%B0%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D0%BE%D0%B6%D0%B0%D0%BB%D0%BE%D0%B2%D0%B0%D0%BB%D0%B8%D1%81%D1%8C%20%E2%80%94%C2%A0%D0%B1%D1%83%D0%B4%D0%B5%D1%82%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0). Соответственно сервис должен уметь работать с вариативностью, а пользователь указывать варианты сообщения.
    - 
- **Instagram (Direct):**
    
    - **Новые аккаунты (менее недели):** до **20 сообщений в Direct в сутки**[postium.ru](https://postium.ru/limity-instagram/#:~:text=%D0%94%D0%BB%D1%8F%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D0%B0%3A).
        
    - **Молодые аккаунты (до 6 месяцев):** до **40 сообщений/сутки**[postium.ru](https://postium.ru/limity-instagram/#:~:text=,%D1%81%D1%83%D1%82%D0%BA%D0%B8).
        
    - **Старые аккаунты:** до **50 сообщений/сутки**[postium.ru](https://postium.ru/limity-instagram/#:~:text=,%D1%81%D1%83%D1%82%D0%BA%D0%B8).
        
    - **Пауза между отправками Direct-сообщений:** не менее **8-10 минут**[postium.ru](https://postium.ru/limity-instagram/#:~:text=%2A%20%D0%BF%D0%B0%D1%83%D0%B7%D1%8B%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D0%BB%D0%B0%D0%B9%D0%BA%D0%B0%D0%BC%D0%B8%3A%2025,10%20%D0%BC%D0%B8%D0%BD%D1%83%D1%82) (Instagram очень чувствителен к частоте, т.к. обычные пользователи не пишут десяткам незнакомых людей в минуту).
        
    - **Контент сообщений:** должен быть персонализированным. **Запрещено шаблонное спам-сообщение** многим пользователям – алгоритмы ИИ Instagram распознают одинаковый текст и могут быстро ограничить функцию отправки сообщений[postium.ru](https://postium.ru/limity-instagram/#:~:text=,%D1%81%D1%83%D1%82%D0%BA%D0%B8). Сервис должен поддерживать шаблоны с подстановками (например, имя пользователя) либо разные вариации текста.
        
    - **Другие действия:** (на будущее) подписки, лайки тоже лимитированы, но Invite Service касается только сообщений/инвайтов.
        
- **WhatsApp:**
    
    - **Official Business API:**
        
        - **Tier 1 (начальный):** до **250 уникальных получателей в сутки**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Tier%201). Все номера стартуют с Tier 1.
            
        - **Tier 2:** до **1000 получателей/сутки**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Tier%202) (повышается автоматически после успешной активной отправки с хорошим рейтингом качества).
            
        - **Tier 3:** до **10 000 получателей/сутки**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Tier%203).
            
        - **Tier 4:** до **100 000 получателей/сутки**[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Allows%20you%20to%20have%2010%2C000,hour%20period).
            
        - **Unlimited:** >100k/сутки, доступно топ-аккаунтам[learn.turn.io](https://learn.turn.io/l/en/article/uvdz8tz40l-quality-ratings-and-messaging-limits#:~:text=Allows%20you%20to%20have%2010%2C000,hour%20period).
            
        - **Скорость через API:** 80 msg/sec по умолчанию на номер, 1000 msg/sec при повышении throughput (при масштабных рассылках)[developers.facebook.com](https://developers.facebook.com/docs/whatsapp/cloud-api/overview/#:~:text=Overview%20,1%2C000%20mps%20by%20automatic%20upgrade). Это очень высокая скорость; обычно ограничение не в технической скорости, а в лимите контактов и поддержании качества.
            
        - **Quality Rating:** нужно отслеживать метрику качества (Low/Medium/High) – она падает, если много пользователей жалуются или блокируют бот. При низком качестве Meta не повысит лимиты и может даже понизить tier. Invite Service при интеграции с WABA должен соблюдать требования шаблонов (например, использовать одобренные message templates для холодных рассылок).
            
    - **Обычные WA-клиенты:**
        
        - Жестких цифр нет, но практика: **не более ~50 исходящих чатов в день на номер**, иначе риск бана. Особенно если контакты не сохраняли ваш номер – WhatsApp опирается на обратную связь (жалобы, блокировки контакта).
            
        - **Broadcast списки:** ограничены 256 контактами, и сообщение доставляется только тем, у кого ваш номер в адресной книге. Таким образом, эффективность спама обычным WA очень ограничена.
            
        - **Forward лимиты:** если нужно разослать одно и то же сообщение, WhatsApp ограничивает форвард: 1 сообщение можно переслать максимум в 5 чатов одновременно[faq.whatsapp.com](https://faq.whatsapp.com/1053543185312573#:~:text=About%20forwarding%20limits%20,can%20only%20be%20shared) (и помечает его как "forwarded many times", что снижает доверие).
            
        - **Рекомендация:** для массовых оповещений **использовать официальную API**. Если все же использовать обычные клиенты (например, эмулируя через WhatsApp Web), нужно крайне консервативно подходить к объему – например, разбивать рассылку на недели, отправлять по нескольку сообщений в час с имитацией человеческого поведения. Invite Service может поддержать это чисто технически, но бизнес-риск (блокировка номера) остается на клиенте.
            

Все перечисленные лимиты должны быть **закодированы в конфигурации** Invite Service (в виде констант или в базе, чтобы было легко обновлять). Также можно реализовать **авто-обновление** некоторых лимитов: например, Telegram иногда меняет правила, или Instagram ужесточает политики – эти изменения нужно отслеживать и корректировать параметры. Документация или блоги (например, Unisender или Postium, цитированные выше) могут служить источником обновлений[tenchat.ru](https://tenchat.ru/media/2072119-kak-zapustit-massovuyu-rassylku-v-telegram-bez-problem#:~:text=%D0%9B%D0%B8%D0%BC%D0%B8%D1%82%D1%8B%20%D0%B4%D0%BB%D1%8F%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D0%B0)[postium.ru](https://postium.ru/limity-instagram/#:~:text=%D0%94%D0%BB%D1%8F%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D0%B0%3A).

## Безопасность

При разработке Invite Service особое внимание уделяется безопасности данных и соответствию политике платформ:

- **Авторизация и аутентификация:** Все запросы к API Invite Service проверяются на наличие и валидность JWT-токена. Токен выдается сервисом аутентификации SaaS-продукта и содержит идентификатор пользователя, роль и т.п. Invite Service доверяет JWT, валидирует подпись (например, с помощью публичного ключа или секрета), и использует embedded user_id для ограничений доступа. Таким образом, **пользователь A не может запустить/просмотреть задачи пользователя B**. Попытки доступа с неправильным токеном возвращают 401/403.
    
- **Изоляция пользователей:** Внутренняя реализация хранит все данные (задачи, списки получателей, логи) с полем `user_id`. Любые запросы на получение данных фильтруются по user_id из токена. Например, даже если кто-то узнает task_id другого пользователя, запрос `GET /invite/{task_id}/status` вернет ошибку «Not found», так как будет проверка соответствия `task.owner_id == auth_user_id`.
    
- **Доступ к аккаунтам:** При создании задачи пользователь указывает, какие аккаунты использовать (либо по умолчанию – все доступные данного типа). Invite Service запрашивает integration-service только для аккаунтов данного пользователя. Integration-service на своей стороне тоже должен удостовериться, что токен принадлежит этому пользователю и выдавать только его аккаунты. Коммуникация между сервисами проходит по доверенному каналу (внутренней сети), но можно дополнительно подписывать межсервисные запросы или использовать mTLS.
    
- **Хранение секретов:** Ключи API, токены доступа, session файлы – все эти секретные данные никогда не пишутся в логи или ответы API. Хранение – только в **Vault** (HashiCorp Vault) или аналогичном защищенном хранилище. Invite Service получает секреты только во время выполнения задачи и держит их в оперативной памяти. Рекомендуется по завершении задачи (или при длительной паузе) выгружать клиентские объекты и очищать из памяти чувствительную информацию. Если Celery-воркер работает постоянно и может обработать несколько задач разных пользователей, имеет смысл изолировать задания по процессам (чтобы в памяти процесса не накапливались данные разных пользователей). Можно добиться этого, например, перезапуская воркер после каждой задачи или используя отдельные очереди/пулы воркеров на пользователя – однако это накладно. При правильной очистке данных этого можно избежать.
    
- **Шифрование трафика:** Все вызовы Invite Service API должны происходить по HTTPS (предположительно, через API Gateway с SSL). Взаимодействие с внешними платформами (Telegram, Instagram, WhatsApp) тоже по зашифрованным протоколам:
    
    - Telegram client API общается через MTProto (шифровано).
        
    - Instagram Graph API – через HTTPS.
        
    - WhatsApp Cloud API – через HTTPS.  
        Если какие-то библиотеки требуют явной настройки TLS – это надо учесть.
        
- **Валидация входных данных:** Пользовательские вводимые данные (списки контактов, тексты сообщений) должны быть проверены. Например, если пользователь загружает CSV, нужно убедиться, что он правильно отформатирован, ограничить максимальный размер файла (во избежание перегрузки/атаки). Текст сообщения желательно ограничить по длине (Telegram – до 4096 символов в сообщении[unisender.com](https://www.unisender.com/ru/blog/kakie-limity-est-v-telegram/#:~:text=%D0%94%D0%BB%D0%B8%D0%BD%D0%B0%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%3A%20%D0%B4%D0%BE%204096,Premium%20%E2%80%94%20%D0%B4%D0%BE%204), WhatsApp – 4096 тоже, Instagram – ~1000). Также **не разрешать HTML/скрипты** в тексте, даже если они в будущем не используются напрямую (чтобы не было XSS при отображении отчетов, если где-то отобразим текст).
    
- 
    

## Мониторинг и логирование

Для поддержания высокого качества сервиса необходимы инструменты мониторинга и логирования:

**Логирование:**

- Каждый ключевой шаг Invite Service должен логироваться с уровнем INFO или DEBUG (в зависимости от необходимости), а ошибки – с уровнем WARNING/ERROR.
    
- Логирование распределяется на несколько категорий:
    
    - **User Actions Logs:** действия пользователя (создал задачу, поставил на паузу, отменил) – можно логировать как Audit Log (с user_id, действием, временем).
        
    - **Task Execution Logs:** автоматические события в ходе выполнения задачи: отправлено сообщение пользователю X (успех), не удалось пригласить Y (приватность), аккаунт Z уходит на паузу 1 час (FloodWait) и т.п. Эти логи могут быть довольно объемными при тысячах получателей, поэтому по умолчанию их уровень DEBUG, но при отладке конкретной задачи их можно включить. В целом, достаточно агрегировать статистику вместо логирования каждого пользователя, чтобы не утонуть в логах.
        
    - **Error Logs:** случаи блокировок, исключения из библиотек, сбои сети – с полным трейсбеком на ERROR. Желательно интегрировать **Sentry** или аналог для отслеживания исключений – тогда команда сразу узнает, если вдруг произошла непредвиденная ошибка в коде.
        
- **Скрытие конфиденциальности:** логи не должны содержать персональных данных пользователей-конечных получателей (PII). Например, вместо полного телефона можно логировать последние 4 цифры или хеш. И уж тем более нельзя логировать содержимое отправляемых сообщений, если там потенциально есть приватная информация. Логировать стоит лишь метаданные: «сообщение отправлено», «приглашение успешно» или код ошибки.
    
- Лог-файлы/потоки должны отправляться в централизованное хранилище (например, ELK, Graylog). Настроить поиск по task_id, user_id, чтобы при инцидентах быстро отфильтровать нужные события.
    

**Мониторинг:**

- Использовать систему метрик, например **Prometheus + Grafana**, для сбора данных о работе сервиса. Ввести метрики:
    
    - **invite_active_tasks{platform}** – количество активных задач рассылки по платформам.
        
    - **invite_processed_users_total{platform}** – счетчик обработанных получателей (общий и с результатами: invited, messaged, failed – можно как отдельные метрики).
        
    - **invite_account_blocks_total{platform}** – счетчик случаев блокировки аккаунтов. Например, Telegram: сколько раз получили SpamBan, WhatsApp: сколько номеров забанено. Это важно отслеживать – резкий скачок будет сигналом проблемы.
        
    - **invite_floodwait_events{platform}** – количество событий флуда/ограничений. Например, сколько FloodWait исключений словили.
        
    - **current_speed_messages_per_minute** – оценочная текущая скорость (можно измерять как скользящее среднее по последним N действиям).
        
    - **task_waiting_queue** – размер очереди задач (Celery) в данный момент. Если растет – система не справляется в реальном времени, нужно больше воркеров.
        
    - **external_api_errors{platform}** – метрика ошибок внешнего API (вдруг Telegram API начал возвращать 500).
        
    - Стандартные метрики по ресурсам: загрузка CPU, память, и по Celery: время выполнения задач, количество ретраев.
        
- **Celery Monitoring:** Развернуть Flower или Celery Exporter, чтобы видеть состояние очередей, прогресс задач, удачные/неудачные. Но т.к. мы храним прогресс в БД, основной источник правды – сама БД и наши метрики.
    
- **Alerts:** Настроить оповещения на ключевые события:
    
    - Если какой-то аккаунт заблокирован (особенно если **много** аккаунтов заблокировано в короткий период) – слать уведомление команде (например, в Slack). Это может означать изменение антиспам правил платформы или утечку контента, на который жалуются.
        
    - Если резко увеличилось число FloodWait – возможно, нужна динамическая настройка параметров (снизить скорость). Можно реализовать автоматическую реакцию: напр. если floodwait_event > X в час, снижать глобальный лимит скорости на 20%. Но на первом этапе достаточно оповещения.
        
    - Отслеживать **длительные задачи** – если задача висит дольше, чем рассчитано, или воркер завис – нужно уведомление.
        
    - Если использование CPU/RAM близко к пределам – добавить воркеры или расследовать (может утечка памяти).
        
- **Отладка и тестирование:** В Invite Service можно предусмотреть режим песочницы – выполнять “сухой запуск” (dry run), когда сервис проходит по всем шагам, но не отправляет реальные сообщения. Это полезно для тестов и для демонстрации. В этом режиме, конечно, и статистика будет фиктивной. Но при боевом использовании  все рассылки реальные.
    
- **Логирование действий платформы:** Например, Telegram-клиент (Telethon) может логировать свои события. Желательно настроить уровень логов библиотек на WARN, чтобы не было лишней информации, но при этом, если Telegram API вернул конкретный код ошибки, мы бы увидели его.
    
- **Monitoring внешних зависимостей:** Следует также мониторить связь с integration-service, parsing-service и Vault. Если, скажем, Vault недоступен, задачи не смогут стартовать. Механизм повторов: Invite Service при ошибке соединения с внешним сервисом должен логировать и ретраить несколько раз, и уведомлять админов, если зависимость недоступна.
    


