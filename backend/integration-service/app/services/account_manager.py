"""
Account Manager Service
–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Telegram –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏ –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞
"""
import logging
import asyncio
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_, or_, func
from sqlalchemy.orm import selectinload
import redis
import json

from ..models.telegram_sessions import TelegramSession
from ..models.account_manager_types import (
    AccountStatus, ActionType, AccountPurpose, ErrorType,
    AccountLimits, AccountUsageStats, TelegramAccountAllocation,
    AccountErrorResult, FloodWaitInfo, AccountHealthStatus
)
from ..core.config import get_settings
from .integration_log_service import IntegrationLogService

logger = logging.getLogger(__name__)

class AccountManagerService:
    """–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Telegram –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏"""
    
    def __init__(self):
        self.settings = get_settings()
        self.log_service = IntegrationLogService()
        
        # Redis –¥–ª—è distributed locks
        self.redis_client = redis.Redis(
            host=self.settings.REDIS_HOST,
            port=self.settings.REDIS_PORT,
            db=self.settings.REDIS_DB + 1,  # –û—Ç–¥–µ–ª—å–Ω–∞—è DB –¥–ª—è Account Manager
            decode_responses=True
        )
        
        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–∏–º–∏—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        self.default_limits = AccountLimits()
        
        # Timeout –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ (–º–∏–Ω—É—Ç—ã)
        self.default_lock_timeout = 30
    
    async def allocate_account(
        self,
        session: AsyncSession,
        user_id: int,
        purpose: AccountPurpose,
        service_name: str = "unknown",
        preferred_account_id: Optional[UUID] = None,
        timeout_minutes: int = None
    ) -> Optional[TelegramAccountAllocation]:
        """
        –í—ã–¥–µ–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–µ—Ä–≤–∏—Å–æ–º
        
        Args:
            session: Database session
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            purpose: –¶–µ–ª—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞
            service_name: –ò–º—è —Å–µ—Ä–≤–∏—Å–∞, –∑–∞–ø—Ä–∞—à–∏–≤–∞—é—â–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç
            preferred_account_id: –ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç (–µ—Å–ª–∏ –µ—Å—Ç—å)
            timeout_minutes: –¢–∞–π–º–∞—É—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö
        
        Returns:
            TelegramAccountAllocation –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤
        """
        try:
            logger.info(f"üîç Allocating account for user {user_id}, purpose: {purpose}, service: {service_name}")
            
            timeout_minutes = timeout_minutes or self.default_lock_timeout
            expires_at = datetime.utcnow() + timedelta(minutes=timeout_minutes)
            
            # 1. –ù–∞–π—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã
            available_accounts = await self._find_available_accounts(
                session, user_id, purpose, preferred_account_id
            )\n            \n            if not available_accounts:\n                logger.warning(f\"‚ùå No available accounts for user {user_id}, purpose: {purpose}\")\n                return None\n            \n            # 2. –í—ã–±—Ä–∞—Ç—å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç\n            selected_account = await self._select_optimal_account(available_accounts, purpose)\n            \n            # 3. –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç —Å distributed lock\n            lock_acquired = await self._acquire_account_lock(\n                selected_account.id, service_name, timeout_minutes\n            )\n            \n            if not lock_acquired:\n                logger.warning(f\"‚ùå Failed to acquire lock for account {selected_account.id}\")\n                return None\n            \n            # 4. –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\n            await session.execute(\n                update(TelegramSession)\n                .where(TelegramSession.id == selected_account.id)\n                .values(\n                    locked=True,\n                    locked_by=service_name,\n                    locked_until=expires_at,\n                    last_used_at=datetime.utcnow()\n                )\n            )\n            await session.commit()\n            \n            # 5. –°–æ–∑–¥–∞—Ç—å allocation –æ–±—ä–µ–∫—Ç\n            allocation = TelegramAccountAllocation(\n                account_id=selected_account.id,\n                user_id=selected_account.user_id,\n                phone=selected_account.phone,\n                session_data=selected_account.session_data,\n                allocated_at=datetime.utcnow(),\n                allocated_by=service_name,\n                purpose=purpose,\n                expires_at=expires_at,\n                limits=self.default_limits,\n                current_usage={\n                    'invites_today': selected_account.used_invites_today,\n                    'messages_today': selected_account.used_messages_today,\n                    'contacts_today': selected_account.contacts_today\n                }\n            )\n            \n            # 6. –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é\n            await self.log_service.log_integration_action(\n                session=session,\n                user_id=user_id,\n                integration_type=\"telegram\",\n                action=\"account_allocated\",\n                status=\"success\",\n                details={\n                    \"account_id\": str(selected_account.id),\n                    \"phone\": selected_account.phone,\n                    \"purpose\": purpose,\n                    \"service\": service_name,\n                    \"expires_at\": expires_at.isoformat()\n                }\n            )\n            \n            logger.info(f\"‚úÖ Account {selected_account.id} allocated to {service_name} for {timeout_minutes} minutes\")\n            return allocation\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error allocating account: {e}\")\n            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏, –æ—Å–≤–æ–±–æ–¥–∏—Ç—å lock –µ—Å–ª–∏ –±—ã–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω\n            if 'selected_account' in locals():\n                await self._release_account_lock(selected_account.id, service_name)\n            raise\n    \n    async def release_account(\n        self,\n        session: AsyncSession,\n        account_id: UUID,\n        service_name: str,\n        usage_stats: AccountUsageStats\n    ) -> bool:\n        \"\"\"\n        –û—Å–≤–æ–±–æ–¥–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n        \n        Args:\n            session: Database session\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            service_name: –ò–º—è —Å–µ—Ä–≤–∏—Å–∞\n            usage_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n        \n        Returns:\n            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏\n        \"\"\"\n        try:\n            logger.info(f\"üîì Releasing account {account_id} from {service_name}\")\n            \n            # 1. –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∞–∫–∫–∞—É–Ω—Ç\n            result = await session.execute(\n                select(TelegramSession).where(TelegramSession.id == account_id)\n            )\n            account = result.scalar_one_or_none()\n            \n            if not account:\n                logger.error(f\"‚ùå Account {account_id} not found\")\n                return False\n            \n            # 2. –û–±–Ω–æ–≤–∏—Ç—å –ª–∏–º–∏—Ç—ã based on usage_stats\n            new_values = {\n                'locked': False,\n                'locked_by': None,\n                'locked_until': None,\n                'last_used_at': datetime.utcnow()\n            }\n            \n            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n            if usage_stats.invites_sent > 0:\n                new_values['used_invites_today'] = account.used_invites_today + usage_stats.invites_sent\n            \n            if usage_stats.messages_sent > 0:\n                new_values['used_messages_today'] = account.used_messages_today + usage_stats.messages_sent\n            \n            if usage_stats.contacts_added > 0:\n                new_values['contacts_today'] = account.contacts_today + usage_stats.contacts_added\n            \n            # –û–±–Ω–æ–≤–ª—è–µ–º per-channel —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n            if usage_stats.channels_used:\n                current_per_channel = account.per_channel_invites or {}\n                for channel_id in usage_stats.channels_used:\n                    if channel_id not in current_per_channel:\n                        current_per_channel[channel_id] = {'today': 0, 'total': 0}\n                    \n                    current_per_channel[channel_id]['today'] += usage_stats.invites_sent\n                    current_per_channel[channel_id]['total'] += usage_stats.invites_sent\n                \n                new_values['per_channel_invites'] = current_per_channel\n            \n            # 3. –ï—Å–ª–∏ –±—ã–ª–∞ –æ—à–∏–±–∫–∞, –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –µ–µ\n            if not usage_stats.success and usage_stats.error_type:\n                error_result = await self.handle_account_error(\n                    session, account_id, usage_stats.error_type, \n                    usage_stats.error_message or \"Unknown error\",\n                    {'service': service_name}\n                )\n                \n                # –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏\n                if error_result:\n                    new_values['status'] = error_result.new_status\n                    if error_result.recovery_time:\n                        if error_result.error_type == ErrorType.FLOOD_WAIT:\n                            new_values['flood_wait_until'] = error_result.recovery_time\n                        elif error_result.error_type in [ErrorType.PEER_FLOOD, ErrorType.PHONE_NUMBER_BANNED]:\n                            new_values['blocked_until'] = error_result.recovery_time\n            \n            # 4. –ü—Ä–∏–º–µ–Ω–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è\n            await session.execute(\n                update(TelegramSession)\n                .where(TelegramSession.id == account_id)\n                .values(**new_values)\n            )\n            await session.commit()\n            \n            # 5. –û—Å–≤–æ–±–æ–¥–∏—Ç—å distributed lock\n            await self._release_account_lock(account_id, service_name)\n            \n            # 6. –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é\n            await self.log_service.log_integration_action(\n                session=session,\n                user_id=account.user_id,\n                integration_type=\"telegram\",\n                action=\"account_released\",\n                status=\"success\",\n                details={\n                    \"account_id\": str(account_id),\n                    \"service\": service_name,\n                    \"usage_stats\": {\n                        \"invites_sent\": usage_stats.invites_sent,\n                        \"messages_sent\": usage_stats.messages_sent,\n                        \"contacts_added\": usage_stats.contacts_added,\n                        \"success\": usage_stats.success,\n                        \"error_type\": usage_stats.error_type\n                    }\n                }\n            )\n            \n            logger.info(f\"‚úÖ Account {account_id} released successfully\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error releasing account {account_id}: {e}\")\n            return False\n    \n    async def _find_available_accounts(\n        self,\n        session: AsyncSession,\n        user_id: int,\n        purpose: AccountPurpose,\n        preferred_account_id: Optional[UUID] = None\n    ) -> List[TelegramSession]:\n        \"\"\"\n        –ù–∞–π—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è\n        \"\"\"\n        now = datetime.utcnow()\n        \n        # –ë–∞–∑–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –∞–∫–∫–∞—É–Ω—Ç–∞\n        conditions = [\n            TelegramSession.user_id == user_id,\n            TelegramSession.is_active == True,\n            TelegramSession.locked == False,\n            TelegramSession.status == AccountStatus.ACTIVE,\n            or_(\n                TelegramSession.flood_wait_until.is_(None),\n                TelegramSession.flood_wait_until <= now\n            ),\n            or_(\n                TelegramSession.blocked_until.is_(None),\n                TelegramSession.blocked_until <= now\n            )\n        ]\n        \n        # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç\n        if preferred_account_id:\n            conditions.append(TelegramSession.id == preferred_account_id)\n        \n        query = select(TelegramSession).where(and_(*conditions))\n        \n        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É (–º–µ–Ω—å—à–µ –≤—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω)\n        query = query.order_by(\n            TelegramSession.used_invites_today.asc(),\n            TelegramSession.used_messages_today.asc(),\n            TelegramSession.last_used_at.asc().nulls_first()\n        )\n        \n        result = await session.execute(query)\n        accounts = result.scalars().all()\n        \n        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ª–∏–º–∏—Ç–∞–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ü–µ–ª–∏\n        filtered_accounts = []\n        for account in accounts:\n            if purpose == AccountPurpose.INVITE_CAMPAIGN and account.can_send_invite():\n                filtered_accounts.append(account)\n            elif purpose == AccountPurpose.MESSAGE_CAMPAIGN and account.can_send_message():\n                filtered_accounts.append(account)\n            elif purpose in [AccountPurpose.PARSING, AccountPurpose.GENERAL]:\n                filtered_accounts.append(account)\n        \n        return filtered_accounts\n    \n    async def _select_optimal_account(\n        self,\n        accounts: List[TelegramSession],\n        purpose: AccountPurpose\n    ) -> TelegramSession:\n        \"\"\"\n        –í—ã–±—Ä–∞—Ç—å –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö\n        \"\"\"\n        if not accounts:\n            raise ValueError(\"No accounts provided\")\n        \n        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ—Å—Ç–∏\n        def account_score(account: TelegramSession) -> float:\n            score = 0.0\n            \n            # –ß–µ–º –º–µ–Ω—å—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω, —Ç–µ–º –ª—É—á—à–µ\n            if purpose == AccountPurpose.INVITE_CAMPAIGN:\n                usage_ratio = account.used_invites_today / account.daily_invite_limit\n            elif purpose == AccountPurpose.MESSAGE_CAMPAIGN:\n                usage_ratio = account.used_messages_today / account.daily_message_limit\n            else:\n                usage_ratio = (account.used_invites_today + account.used_messages_today) / 60\n            \n            score += (1.0 - usage_ratio) * 100\n            \n            # –ë–æ–Ω—É—Å –∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –Ω–µ–¥–∞–≤–Ω–∏—Ö –æ—à–∏–±–æ–∫\n            if account.error_count == 0:\n                score += 10\n            \n            # –ë–æ–Ω—É—Å –∑–∞ –¥–∞–≤–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n            if account.last_used_at:\n                hours_since_use = (datetime.utcnow() - account.last_used_at).total_seconds() / 3600\n                score += min(hours_since_use, 24)  # –ú–∞–∫—Å–∏–º—É–º 24 —á–∞—Å–∞\n            else:\n                score += 24  # –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è\n            \n            return score\n        \n        # –í—ã–±–∏—Ä–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç —Å –Ω–∞–∏–≤—ã—Å—à–∏–º score\n        optimal_account = max(accounts, key=account_score)\n        return optimal_account\n    \n    async def _acquire_account_lock(\n        self,\n        account_id: UUID,\n        service_name: str,\n        timeout_minutes: int\n    ) -> bool:\n        \"\"\"\n        –ü–æ–ª—É—á–∏—Ç—å distributed lock –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç\n        \"\"\"\n        lock_key = f\"account_lock:{account_id}\"\n        lock_value = f\"{service_name}:{datetime.utcnow().isoformat()}\"\n        \n        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º lock —Å TTL\n        result = self.redis_client.set(\n            lock_key, \n            lock_value, \n            nx=True,  # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –∫–ª—é—á –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç\n            ex=timeout_minutes * 60  # TTL –≤ —Å–µ–∫—É–Ω–¥–∞—Ö\n        )\n        \n        if result:\n            logger.debug(f\"üîí Acquired lock for account {account_id} by {service_name}\")\n            return True\n        else:\n            logger.warning(f\"‚ùå Failed to acquire lock for account {account_id}, already locked\")\n            return False\n    \n    async def _release_account_lock(\n        self,\n        account_id: UUID,\n        service_name: str\n    ) -> bool:\n        \"\"\"\n        –û—Å–≤–æ–±–æ–¥–∏—Ç—å distributed lock –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç\n        \"\"\"\n        lock_key = f\"account_lock:{account_id}\"\n        \n        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ lock\n        current_value = self.redis_client.get(lock_key)\n        \n        if current_value and current_value.startswith(f\"{service_name}:\"):\n            # –£–¥–∞–ª—è–µ–º lock —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –Ω–∞—à–µ–º—É —Å–µ—Ä–≤–∏—Å—É\n            self.redis_client.delete(lock_key)\n            logger.debug(f\"üîì Released lock for account {account_id} by {service_name}\")\n            return True\n        elif current_value:\n            logger.warning(f\"‚ùå Cannot release lock for account {account_id}, owned by: {current_value}\")\n            return False\n        else:\n            # Lock —É–∂–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç\n            return True\n    \n    async def handle_account_error(\n        self,\n        session: AsyncSession,\n        account_id: UUID,\n        error_type: ErrorType,\n        error_message: str,\n        context: Dict[str, Any] = None\n    ) -> Optional[AccountErrorResult]:\n        \"\"\"\n        –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É –∞–∫–∫–∞—É–Ω—Ç–∞\n        \n        Args:\n            session: Database session\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            error_type: –¢–∏–ø –æ—à–∏–±–∫–∏\n            error_message: –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ\n            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        \n        Returns:\n            AccountErrorResult —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø—Ä–∏–Ω—è—Ç—ã—Ö –º–µ—Ä–∞—Ö\n        \"\"\"\n        try:\n            logger.warning(f\"‚ö†Ô∏è Handling account error: {error_type} for account {account_id}\")\n            \n            context = context or {}\n            now = datetime.utcnow()\n            \n            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ –æ—à–∏–±–∫–∏\n            if error_type == ErrorType.FLOOD_WAIT:\n                # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è\n                import re\n                match = re.search(r'(\\d+)', error_message)\n                seconds = int(match.group(1)) if match else 300  # Fallback: 5 –º–∏–Ω—É—Ç\n                \n                recovery_time = now + timedelta(seconds=seconds + 60)  # +1 –º–∏–Ω—É—Ç–∞ –±—É—Ñ–µ—Ä\n                new_status = AccountStatus.FLOOD_WAIT\n                action_taken = f\"Set flood wait until {recovery_time}\"\n                should_retry = True\n                \n            elif error_type == ErrorType.PEER_FLOOD:\n                recovery_time = now + timedelta(hours=24)  # 24 —á–∞—Å–∞\n                new_status = AccountStatus.BLOCKED\n                action_taken = \"Blocked for 24 hours due to peer flood\"\n                should_retry = False\n                \n            elif error_type in [ErrorType.PHONE_NUMBER_BANNED, ErrorType.USER_DEACTIVATED]:\n                recovery_time = None  # Permanent\n                new_status = AccountStatus.DISABLED\n                action_taken = \"Permanently disabled\"\n                should_retry = False\n                \n            elif error_type == ErrorType.AUTH_KEY_ERROR:\n                recovery_time = None\n                new_status = AccountStatus.DISABLED\n                action_taken = \"Disabled due to auth key error\"\n                should_retry = False\n                \n            else:\n                # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫\n                recovery_time = now + timedelta(minutes=30)\n                new_status = AccountStatus.ACTIVE  # –û—Å—Ç–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–º\n                action_taken = \"Incremented error count\"\n                should_retry = True\n            \n            # –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫–∫–∞—É–Ω—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö\n            update_values = {\n                'status': new_status,\n                'error_count': TelegramSession.error_count + 1\n            }\n            \n            if error_type == ErrorType.FLOOD_WAIT and recovery_time:\n                update_values['flood_wait_until'] = recovery_time\n            elif error_type in [ErrorType.PEER_FLOOD, ErrorType.PHONE_NUMBER_BANNED] and recovery_time:\n                update_values['blocked_until'] = recovery_time\n            \n            await session.execute(\n                update(TelegramSession)\n                .where(TelegramSession.id == account_id)\n                .values(**update_values)\n            )\n            await session.commit()\n            \n            # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n            result = AccountErrorResult(\n                account_id=account_id,\n                error_type=error_type,\n                action_taken=action_taken,\n                new_status=new_status,\n                recovery_time=recovery_time,\n                should_retry=should_retry,\n                message=f\"Error handled: {error_message}\"\n            )\n            \n            # –õ–æ–≥–∏—Ä—É–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é\n            await self.log_service.log_integration_action(\n                session=session,\n                user_id=context.get('user_id', 0),\n                integration_type=\"telegram\",\n                action=\"account_error_handled\",\n                status=\"success\",\n                details={\n                    \"account_id\": str(account_id),\n                    \"error_type\": error_type,\n                    \"error_message\": error_message,\n                    \"action_taken\": action_taken,\n                    \"new_status\": new_status,\n                    \"recovery_time\": recovery_time.isoformat() if recovery_time else None,\n                    \"context\": context\n                }\n            )\n            \n            logger.info(f\"‚úÖ Error handled for account {account_id}: {action_taken}\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error handling account error: {e}\")\n            return None