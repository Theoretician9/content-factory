"""
API endpoints –¥–ª—è Telegram –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π —á–µ—Ä–µ–∑ Integration Service
–¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Account Manager –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤
"""

from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from telethon.errors import FloodWaitError, PeerFloodError, UserNotMutualContactError
# –£–±—Ä–∞–ª PrivacyRestrictedError - –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏ telethon
from telethon.tl.functions.channels import InviteToChannelRequest
from telethon.tl.functions.messages import AddChatUserRequest
from typing import Dict, Any, Optional
from datetime import datetime
from uuid import UUID
import asyncio
import logging

# –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ò–ú–ü–û–†–¢–´ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ä–µ–∞–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
from ....database import get_async_session
from ....models.telegram_sessions import TelegramSession
from ....models.account_manager_types import AccountPurpose, ActionType, ErrorType, AccountUsageStats
from ....core.auth import get_user_id_from_request
from ....schemas.telegram_invites import (
    TelegramInviteRequest,
    TelegramInviteResponse,
    TelegramMessageRequest,
    TelegramMessageResponse,
    TelegramAccountLimitsResponse
)
from ....services.telegram_service import TelegramService
from ....services.account_manager import AccountManagerService

router = APIRouter()
logger = logging.getLogger(__name__)


def get_telegram_service() -> TelegramService:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ Telegram Service"""
    return TelegramService()

def get_account_manager() -> AccountManagerService:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ Account Manager Service"""
    return AccountManagerService()


@router.post("/accounts/{account_id}/check-admin")
async def check_account_admin_rights(
    account_id: UUID,
    check_data: dict,
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service)
):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã—Ö –ø—Ä–∞–≤ –∞–∫–∫–∞—É–Ω—Ç–∞ –≤ –≥—Ä—É–ø–ø–µ/–∫–∞–Ω–∞–ª–µ"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    user_id = await get_user_id_from_request(request)
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    result = await session.execute(
        select(TelegramSession).where(
            TelegramSession.id == account_id,
            TelegramSession.user_id == user_id
        )
    )
    account = result.scalar_one_or_none()
    
    if not account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Telegram –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞"
        )
    
    group_id = check_data.get("group_id")
    required_permissions = check_data.get("required_permissions", [])
    
    if not group_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="group_id –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω"
        )
    
    # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è group_id –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
    def normalize_group_id(gid: str) -> str:
        """–ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç group_id –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å Telegram API"""
        gid = gid.strip()
        
        # –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ –ø–æ–ª–Ω—ã–π URL - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
        if gid.startswith('https://') or gid.startswith('http://') or gid.startswith('t.me/'):
            return gid
        
        # –ï—Å–ª–∏ —ç—Ç–æ username –±–µ–∑ @, –¥–æ–±–∞–≤–ª—è–µ–º t.me/
        if not gid.startswith('@'):
            return f't.me/{gid}'
        
        # –ï—Å–ª–∏ —ç—Ç–æ @username, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
        return gid
    
    normalized_group_id = normalize_group_id(group_id)
    
    try:
        # –ü–æ–ª—É—á–µ–Ω–∏–µ Telegram –∫–ª–∏–µ–Ω—Ç–∞
        client = await telegram_service.get_client(account)
        
        if not client.is_connected():
            await client.connect()
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–ø–ø–µ/–∫–∞–Ω–∞–ª–µ
        try:
            group = await client.get_entity(normalized_group_id)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã {normalized_group_id} (–æ—Ä–∏–≥–∏–Ω–∞–ª: {group_id}): {str(e)}")
            return {
                "is_admin": False,
                "permissions": [],
                "error": f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–ø–ø–µ: {str(e)}"
            }
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–∏ –ø—Ä–∞–≤–∞ –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ
        try:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—Å–µ–±—è)
            me = await client.get_me()
            logger.info(f"üîç –¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ID={me.id}, —Ç–µ–ª–µ—Ñ–æ–Ω={me.phone}, username={me.username}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞ –≤ –≥—Ä—É–ø–ø–µ
            logger.info(f"üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞ –≤ –≥—Ä—É–ø–ø–µ...")
            
            try:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–µ
                from telethon.tl.functions.channels import GetParticipantRequest
                participant_info = await client(GetParticipantRequest(
                    channel=group,
                    participant=me
                ))
                
                logger.info(f"üîç –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–µ –ø–æ–ª—É—á–µ–Ω–∞: {type(participant_info.participant).__name__}")
                
                participant = participant_info.participant
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —É—á–∞—Å—Ç–Ω–∏–∫–∞
                from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantCreator
                
                my_admin_rights = None
                is_admin = False
                
                if isinstance(participant, ChannelParticipantCreator):
                    # –ö—Ä–µ–∞—Ç–æ—Ä –∏–º–µ–µ—Ç –≤—Å–µ –ø—Ä–∞–≤–∞
                    is_admin = True
                    logger.info(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è –∫—Ä–µ–∞—Ç–æ—Ä–æ–º –≥—Ä—É–ø–ø—ã")
                    # –ö—Ä–µ–∞—Ç–æ—Ä –∏–º–µ–µ—Ç –≤—Å–µ –ø—Ä–∞–≤–∞
                    permissions = ['invite_users', 'ban_users', 'delete_messages', 'post_messages', 'add_admins']
                    
                elif isinstance(participant, ChannelParticipantAdmin):
                    # –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä
                    is_admin = True
                    my_admin_rights = participant.admin_rights
                    logger.info(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–º–µ–µ—Ç admin_rights: {my_admin_rights}")
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø—Ä–∞–≤–∞
                    permissions = []
                    
                    if hasattr(my_admin_rights, 'invite_users') and my_admin_rights.invite_users:
                        permissions.append('invite_users')
                    
                    if hasattr(my_admin_rights, 'ban_users') and my_admin_rights.ban_users:
                        permissions.append('ban_users')
                    
                    if hasattr(my_admin_rights, 'delete_messages') and my_admin_rights.delete_messages:
                        permissions.append('delete_messages')
                    
                    if hasattr(my_admin_rights, 'post_messages') and my_admin_rights.post_messages:
                        permissions.append('post_messages')
                    
                    if hasattr(my_admin_rights, 'add_admins') and my_admin_rights.add_admins:
                        permissions.append('add_admins')
                
                else:
                    # –û–±—ã—á–Ω—ã–π —É—á–∞—Å—Ç–Ω–∏–∫
                    is_admin = False
                    permissions = []
                    logger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º")
                
            except Exception as participant_error:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä—Ä–º–∞—Ü–∏—é –æ–± —É—á–∞—Å—Ç–Ω–∏–∫–µ: {str(participant_error)}")
                
                # Fallback: –ø—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥
                logger.info(f"üîç Fallback: –ø—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥...")
                is_admin = False
                permissions = []
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç—Ä–µ–±—É–µ–º—ã—Ö –ø—Ä–∞–≤
            has_required_permissions = all(perm in permissions for perm in required_permissions)
            
            logger.info(f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏: is_admin={is_admin}")
            
            if is_admin:
                logger.info(f"‚úÖ –ê–∫–∫–∞—É–Ω—Ç {account_id} - –∞–¥–º–∏–Ω: {is_admin}, –ø—Ä–∞–≤–∞: {permissions}")
            else:
                logger.info(f"–ê–∫–∫–∞—É–Ω—Ç {account_id} –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –≤ –≥—Ä—É–ø–ø–µ {group_id}")
            
            return {
                "is_admin": is_admin,
                "permissions": permissions,
                "has_required_permissions": has_required_permissions,
                "group_title": getattr(group, 'title', str(group_id)),
                "message": f"–ê–∫–∫–∞—É–Ω—Ç {'\u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f' if is_admin else '\u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f'} –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–º–∏–Ω –ø—Ä–∞–≤ –¥–ª—è {account_id} –≤ {group_id}: {str(e)}")
            return {
                "is_admin": False,
                "permissions": [],
                "error": f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤: {str(e)}"
            }
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Telegram –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {account_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Telegram: {str(e)}"
        )


@router.post("/accounts/{account_id}/invite", response_model=TelegramInviteResponse)
async def send_telegram_invite_by_account(
    account_id: UUID,
    invite_data: TelegramInviteRequest,
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service)
):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è —á–µ—Ä–µ–∑ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π Telegram –∞–∫–∫–∞—É–Ω—Ç - —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å Invite Service"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    user_id = await get_user_id_from_request(request)
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    result = await session.execute(
        select(TelegramSession).where(
            TelegramSession.id == account_id,
            TelegramSession.user_id == user_id
        )
    )
    account = result.scalar_one_or_none()
    
    if not account:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Telegram –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞"
        )
    
    try:
        # –ü–æ–ª—É—á–µ–Ω–∏–µ Telegram –∫–ª–∏–µ–Ω—Ç–∞
        client = await telegram_service.get_client(account)
        
        if not client.is_connected():
            await client.connect()
        
        start_time = datetime.utcnow()
        result_data = None
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π
        if invite_data.invite_type == "group_invite":
            # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É/–∫–∞–Ω–∞–ª
            if not invite_data.group_id:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="group_id –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è group_invite"
                )
            
            if invite_data.target_username:
                # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø–æ username
                user = await client.get_entity(invite_data.target_username)
                
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º group_id
                def normalize_group_id(gid: str) -> str:
                    """–ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç group_id –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å Telegram API"""
                    gid = gid.strip()
                    if gid.startswith('https://') or gid.startswith('http://') or gid.startswith('t.me/'):
                        return gid
                    if not gid.startswith('@'):
                        return f't.me/{gid}'
                    return gid
                
                normalized_group_id = normalize_group_id(invite_data.group_id)
                group = await client.get_entity(normalized_group_id)
                
                if hasattr(group, 'megagroup') and group.megagroup:
                    # –°—É–ø–µ—Ä–≥—Ä—É–ø–ø–∞
                    result_data = await client(InviteToChannelRequest(
                        channel=group,
                        users=[user]
                    ))
                else:
                    # –û–±—ã—á–Ω–∞—è –≥—Ä—É–ø–ø–∞
                    result_data = await client(AddChatUserRequest(
                        chat_id=group.id,
                        user_id=user.id,
                        fwd_limit=10
                    ))
            
            elif invite_data.target_phone:
                # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞
                contacts = await client.get_contacts()
                user = None
                
                for contact in contacts:
                    if hasattr(contact, 'phone') and contact.phone == invite_data.target_phone.replace('+', ''):
                        user = contact
                        break
                
                if not user:
                    raise HTTPException(
                        status_code=status.HTTP_404_NOT_FOUND,
                        detail=f"–ö–æ–Ω—Ç–∞–∫—Ç —Å –Ω–æ–º–µ—Ä–æ–º {invite_data.target_phone} –Ω–µ –Ω–∞–π–¥–µ–Ω"
                    )
                
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º group_id
                def normalize_group_id(gid: str) -> str:
                    gid = gid.strip()
                    if gid.startswith('https://') or gid.startswith('http://') or gid.startswith('t.me/'):
                        return gid
                    if not gid.startswith('@'):
                        return f't.me/{gid}'
                    return gid
                
                normalized_group_id = normalize_group_id(invite_data.group_id)
                group = await client.get_entity(normalized_group_id)
                result_data = await client(InviteToChannelRequest(
                    channel=group,
                    users=[user]
                ))
            
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="–ù–µ–æ–±—Ö–æ–¥–∏–º target_username –∏–ª–∏ target_phone"
                )
        
        elif invite_data.invite_type == "direct_message":
            # –ü—Ä—è–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            target_entity = invite_data.target_username or invite_data.target_phone
            
            if not target_entity:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="–ù–µ–æ–±—Ö–æ–¥–∏–º target_username –∏–ª–∏ target_phone –¥–ª—è direct_message"
                )
            
            if not invite_data.message:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="–°–æ–æ–±—â–µ–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è direct_message"
                )
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
            result_data = await client.send_message(
                entity=target_entity,
                message=invite_data.message
            )
        
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è: {invite_data.invite_type}"
            )
        
        # –£—Å–ø–µ—à–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        end_time = datetime.utcnow()
        execution_time = (end_time - start_time).total_seconds()
        
        return TelegramInviteResponse(
            success=True,
            message="–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ",
            account_id=account_id,
            target_username=invite_data.target_username,
            target_phone=invite_data.target_phone,
            execution_time=execution_time,
            sent_at=end_time
        )
    
    except FloodWaitError as e:
        # Telegram FloodWait –æ—à–∏–±–∫–∞
        logger.warning(f"FloodWait –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {account_id}: {e.seconds}s")
        
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "error": "flood_wait",
                "message": f"–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å {e.seconds} —Å–µ–∫—É–Ω–¥",
                "retry_after": e.seconds
            }
        )
    
    except PeerFloodError as e:
        # –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –æ–¥–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        logger.warning(f"PeerFlood –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {account_id}")
        
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "error": "peer_flood",
                "message": "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ",
                "retry_after": 86400  # 24 —á–∞—Å–∞
            }
        )
    
    except UserNotMutualContactError as e:
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö
        logger.info(f"User not mutual contact –¥–ª—è {invite_data.target_username or invite_data.target_phone}")
        
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={
                "error": "user_not_mutual_contact",
                "message": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ —Å–ø–∏—Å–∫–µ –≤–∑–∞–∏–º–Ω—ã—Ö –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤"
            }
        )
    
    except Exception as e:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫
        error_msg = str(e).lower()
        
        if "privacy" in error_msg or "restricted" in error_msg:
            logger.info(f"Privacy restricted –¥–ª—è {invite_data.target_username or invite_data.target_phone}")
            
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail={
                    "error": "privacy_restricted",
                    "message": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–ø—Ä–µ—â–∞—é—Ç –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"
                }
            )
        
        # –û–±—â–∏–µ –æ—à–∏–±–∫–∏
        logger.error(f"Telegram invite error –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {account_id}: {str(e)}")
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={
                "error": "invite_failed",
                "message": str(e)
            }
        )


@router.post("/invite", response_model=TelegramInviteResponse)
async def send_telegram_invite(
    invite_data: TelegramInviteRequest,
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service),
    account_manager: AccountManagerService = Depends(get_account_manager)
):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è —á–µ—Ä–µ–∑ Account Manager - –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π  
    user_id = await get_user_id_from_request(request)
    
    # 1. –ó–∞–ø—Ä–æ—Å–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç —É Account Manager
    allocation = await account_manager.allocate_account(
        session=session,
        user_id=user_id,
        purpose=AccountPurpose.INVITATION,
        service_name="integration-service",
        timeout_minutes=30
    )
    
    if not allocation:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail={
                "error": "no_available_accounts",
                "message": "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö Telegram –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π"
            }
        )
    
    # 2. –ü–æ–ª—É—á–∏—Ç—å TelegramSession –ø–æ ID
    result = await session.execute(
        select(TelegramSession).where(TelegramSession.id == allocation.account_id)
    )
    account = result.scalar_one_or_none()
    
    if not account:
        # –û—Å–≤–æ–±–æ–¥–∏—Ç—å –∞–ª–ª–æ–∫–∞—Ü–∏—é –ø—Ä–∏ –æ—à–∏–±–∫–µ
        await account_manager.release_account(
            session=session,
            account_id=allocation.account_id,
            service_name="integration-service",
            usage_stats=AccountUsageStats(success=False, error_type=ErrorType.ACCOUNT_NOT_FOUND)
        )
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Telegram –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    usage_stats = AccountUsageStats(
        invites_sent=0,
        messages_sent=0,
        success=False
    )
    
    try:
        # 3. –ü–æ–ª—É—á–µ–Ω–∏–µ Telegram –∫–ª–∏–µ–Ω—Ç–∞
        client = await telegram_service.get_client(account)
        
        if not client.is_connected():
            await client.connect()
        
        start_time = datetime.utcnow()
        result = None
        
        try:
            if invite_data.invite_type == "group_invite":
                # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É/–∫–∞–Ω–∞–ª
                if invite_data.group_id:
                    if invite_data.target_username:
                        # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø–æ username
                        user = await client.get_entity(invite_data.target_username)
                        group = await client.get_entity(invite_data.group_id)
                        
                        if hasattr(group, 'megagroup') and group.megagroup:
                            # –°—É–ø–µ—Ä–≥—Ä—É–ø–ø–∞
                            result = await client(InviteToChannelRequest(
                                channel=group,
                                users=[user]
                            ))
                        else:
                            # –û–±—ã—á–Ω–∞—è –≥—Ä—É–ø–ø–∞
                            result = await client(AddChatUserRequest(
                                chat_id=group.id,
                                user_id=user.id,
                                fwd_limit=10
                            ))
                        
                        usage_stats.invites_sent = 1
                        usage_stats.channels_used = [str(invite_data.group_id)]
                    
                    elif invite_data.target_phone:
                        # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞
                        contacts = await client.get_contacts()
                        user = None
                        
                        for contact in contacts:
                            if hasattr(contact, 'phone') and contact.phone == invite_data.target_phone.replace('+', ''):
                                user = contact
                                break
                        
                        if not user:
                            raise Exception(f"–ö–æ–Ω—Ç–∞–∫—Ç —Å –Ω–æ–º–µ—Ä–æ–º {invite_data.target_phone} –Ω–µ –Ω–∞–π–¥–µ–Ω")
                        
                        group = await client.get_entity(invite_data.group_id)
                        result = await client(InviteToChannelRequest(
                            channel=group,
                            users=[user]
                        ))
                        
                        usage_stats.invites_sent = 1
                        usage_stats.channels_used = [str(invite_data.group_id)]
                
                else:
                    raise Exception("group_id –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è group_invite")
            
            elif invite_data.invite_type == "direct_message":
                # –ü—Ä—è–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                target_entity = invite_data.target_username or invite_data.target_phone
                
                if not target_entity:
                    raise Exception("–ù–µ–æ–±—Ö–æ–¥–∏–º target_username –∏–ª–∏ target_phone –¥–ª—è direct_message")
                
                if not invite_data.message:
                    raise Exception("–°–æ–æ–±—â–µ–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è direct_message")
                
                # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
                result = await client.send_message(
                    entity=target_entity,
                    message=invite_data.message
                )
                
                usage_stats.messages_sent = 1
            
            else:
                raise Exception(f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è: {invite_data.invite_type}")
            
            # –£—Å–ø–µ—Ö!
            usage_stats.success = True
            
        except FloodWaitError as e:
            # Telegram FloodWait –æ—à–∏–±–∫–∞
            logger.warning(f"FloodWait –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {allocation.account_id}: {e.seconds}s")
            usage_stats.error_type = ErrorType.FLOOD_WAIT
            usage_stats.error_message = f"FloodWait {e.seconds}s"
            
            # –û—Å–≤–æ–±–æ–¥–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É –≤ Account Manager
            await account_manager.handle_account_error(
                session=session,
                account_id=allocation.account_id,
                error_type=ErrorType.FLOOD_WAIT,
                error_message=f"FloodWait {e.seconds}s",
                context={"service": "integration-service", "action": "invite"}
            )
            
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail={
                    "error": "flood_wait",
                    "seconds": e.seconds,
                    "message": f"–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –û–∂–∏–¥–∞–Ω–∏–µ {e.seconds} —Å–µ–∫—É–Ω–¥."
                }
            )
        
        except PeerFloodError as e:
            # –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
            logger.warning(f"PeerFlood –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {allocation.account_id}")
            usage_stats.error_type = ErrorType.PEER_FLOOD
            usage_stats.error_message = "PeerFlood - too many user requests"
            
            # –û—Å–≤–æ–±–æ–¥–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É –≤ Account Manager
            await account_manager.handle_account_error(
                session=session,
                account_id=allocation.account_id,
                error_type=ErrorType.PEER_FLOOD,
                error_message="Too many requests to users",
                context={"service": "integration-service", "action": "invite"}
            )
            
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail={
                    "error": "peer_flood",
                    "message": "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º. –ê–∫–∫–∞—É–Ω—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω."
                }
            )
        
        except UserNotMutualContactError as e:
            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö
            logger.info(f"User not mutual contact: {invite_data.target_username or invite_data.target_phone}")
            usage_stats.error_type = ErrorType.USER_RESTRICTED
            usage_stats.error_message = "User not in contacts"
            
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail={
                    "error": "not_mutual_contact",
                    "message": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –≤–∞—à–∏—Ö –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö"
                }
            )
        
        except Exception as e:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –∏ –¥—Ä—É–≥–∏—Ö –æ–±—â–∏—Ö –æ—à–∏–±–æ–∫
            error_msg = str(e).lower()
            
            if "privacy" in error_msg or "restricted" in error_msg:
                logger.info(f"Privacy restricted –¥–ª—è {invite_data.target_username or invite_data.target_phone}")
                usage_stats.error_type = ErrorType.USER_RESTRICTED
                usage_stats.error_message = "Privacy restrictions"
                
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "error": "privacy_restricted",
                        "message": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–ø—Ä–µ—â–∞—é—Ç –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è"
                    }
                )
            else:
                # –û–±—â–∏–µ –æ—à–∏–±–∫–∏
                logger.error(f"Telegram invite error: {str(e)}")
                usage_stats.error_type = ErrorType.API_ERROR
                usage_stats.error_message = str(e)
                
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail={
                        "error": "invite_failed",
                        "message": str(e)
                    }
                )
        
        # –£—Å–ø–µ—à–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        end_time = datetime.utcnow()
        execution_time = (end_time - start_time).total_seconds()
        
        return TelegramInviteResponse(
            status="success",
            message_id=result.id if hasattr(result, 'id') else None,
            sent_at=end_time,
            execution_time=execution_time,
            message="–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ"
        )
        
    finally:
        # 4. –í–°–ï–ì–î–ê –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç –≤ Account Manager
        try:
            await account_manager.release_account(
                session=session,
                account_id=allocation.account_id,
                service_name="integration-service",
                usage_stats=usage_stats
            )
            logger.info(f"‚úÖ Account {allocation.account_id} released successfully")
        except Exception as release_error:
            logger.error(f"‚ùå Failed to release account {allocation.account_id}: {release_error}")


@router.post("/accounts/{account_id}/message", response_model=TelegramMessageResponse)
async def send_telegram_message(
    account_id: UUID,
    message_data: TelegramMessageRequest,
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service)
):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ Telegram –∞–∫–∫–∞—É–Ω—Ç"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    user_id = await get_user_id_from_request(request)
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–∫–∫–∞—É–Ω—Ç—É
    account = await telegram_service.session_service.get_by_id(session, account_id)
    
    if not account or account.user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Telegram –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    try:
        client = await telegram_service.get_client(account)
        
        if not client.is_connected():
            await client.connect()
        
        start_time = datetime.utcnow()
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
        result = await client.send_message(
            entity=message_data.target_entity,
            message=message_data.message,
            parse_mode='html' if message_data.parse_mode == 'html' else None
        )
        
        end_time = datetime.utcnow()
        execution_time = (end_time - start_time).total_seconds()
        
        return TelegramMessageResponse(
            status="success",
            message_id=result.id,
            sent_at=end_time,
            execution_time=execution_time,
            target_entity=message_data.target_entity
        )
    
    except FloodWaitError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "error": "flood_wait",
                "seconds": e.seconds
            }
        )
    
    except Exception as e:
        logger.error(f"Message send error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}"
        )


@router.get("/accounts")
async def get_user_telegram_accounts(
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service)
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö Telegram –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è Invite Service"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    user_id = await get_user_id_from_request(request)
    
    accounts = await telegram_service.get_user_sessions(session, user_id, active_only=True)
    
    return [
        {
            "id": acc.id,
            "username": getattr(acc, 'username', None),
            "phone": acc.phone,
            "first_name": getattr(acc, 'first_name', None),
            "last_name": getattr(acc, 'last_name', None),
            "status": "active" if acc.is_active else "inactive",
            "created_at": acc.created_at,
            "last_activity": acc.updated_at,
            "daily_limits": {
                "invites": 50,
                "messages": 40
            }
        }
        for acc in accounts
    ]


@router.get("/accounts/{account_id}/limits", response_model=TelegramAccountLimitsResponse)
async def get_account_limits(
    account_id: UUID,
    request: Request,
    session: AsyncSession = Depends(get_async_session),
    telegram_service: TelegramService = Depends(get_telegram_service)
):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ª–∏–º–∏—Ç–∞—Ö –∞–∫–∫–∞—É–Ω—Ç–∞"""
    
    # –ò–∑–æ–ª—è—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    user_id = await get_user_id_from_request(request)
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    account = await telegram_service.session_service.get_by_id(session, account_id)
    
    if not account or account.user_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Telegram –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    # –ë–∞–∑–æ–≤—ã–µ –ª–∏–º–∏—Ç—ã Telegram –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    limits = {
        "daily_invites": 30,      # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π –≤ –¥–µ–Ω—å
        "daily_messages": 30,     # –°–æ–æ–±—â–µ–Ω–∏–π –≤ –¥–µ–Ω—å
        "contacts_daily": 15,     # –ö–æ–Ω—Ç–∞–∫—Ç–æ–≤ –≤ –¥–µ–Ω—å
        "per_channel_daily": 15,  # –ù–∞ –∫–∞–Ω–∞–ª –≤ –¥–µ–Ω—å
        "hourly_invites": 5,      # –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π –≤ —á–∞—Å
        "flood_wait_active": account.flood_wait_until is not None and account.flood_wait_until > datetime.utcnow(),
        "account_restrictions": []
    }
    
    # –¢–µ–∫—É—â–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    current_usage = {
        "daily_invites_used": account.used_invites_today or 0,
        "daily_messages_used": account.used_messages_today or 0,
        "contacts_used": account.contacts_today or 0,
        "hourly_invites_used": 0  # TODO: –∏–∑ Redis
    }
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
    restrictions = []
    if account.blocked_until and account.blocked_until > datetime.utcnow():
        restrictions.append(f"Blocked until {account.blocked_until.isoformat()}")
    if account.flood_wait_until and account.flood_wait_until > datetime.utcnow():
        restrictions.append(f"Flood wait until {account.flood_wait_until.isoformat()}")
    
    return TelegramAccountLimitsResponse(
        account_id=account_id,
        limits=limits,
        current_usage=current_usage,
        restrictions=restrictions,
        last_updated=account.updated_at or datetime.utcnow()
    ) 