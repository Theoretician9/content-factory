"""
Account Manager Client –¥–ª—è Invite Service
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è Telegram –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏
"""
import httpx
import logging
from typing import Optional, Dict, Any, List
from datetime import datetime
from ..core.config import get_settings

logger = logging.getLogger(__name__)

class AccountManagerClient:
    """HTTP –∫–ª–∏–µ–Ω—Ç –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å Account Manager –≤ Integration Service"""
    
    def __init__(self):
        self.settings = get_settings()
        self.base_url = "http://integration-service:8000/api/v1/account-manager"
        self.timeout = 30.0
        
    async def allocate_account(
        self, 
        user_id: int, 
        purpose: str = "invite_campaign",
        preferred_account_id: Optional[str] = None,
        timeout_minutes: int = 30
    ) -> Optional[Dict[str, Any]]:
        """
        –í—ã–¥–µ–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π
        
        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            purpose: –¶–µ–ª—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (invite_campaign)
            preferred_account_id: –ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç
            timeout_minutes: –¢–∞–π–º–∞—É—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö
            
        Returns:
            Dict —Å –¥–∞–Ω–Ω—ã–º–∏ –∞–∫–∫–∞—É–Ω—Ç–∞ –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
        """
        try:
            logger.info(f"üîç Requesting account allocation for user {user_id}, purpose: {purpose}")\n            
            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.post(\n                    f"{self.base_url}/allocate",\n                    json={\n                        "user_id": user_id,\n                        "purpose": purpose,\n                        "service_name": "invite-service",\n                        "preferred_account_id": preferred_account_id,\n                        "timeout_minutes": timeout_minutes\n                    }\n                )\n                \n                if response.status_code == 200:\n                    allocation = response.json()\n                    logger.info(f"‚úÖ Account allocated: {allocation['account_id']}, phone: {allocation['phone']}")\n                    return allocation\n                elif response.status_code == 404:\n                    logger.warning(f"‚ùå No available accounts for user {user_id}")\n                    return None\n                else:\n                    logger.error(f"‚ùå Account allocation failed: {response.status_code} - {response.text}")\n                    response.raise_for_status()\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error allocating account: {e}")\n            return None\n    \n    async def release_account(\n        self,\n        account_id: str,\n        usage_stats: Dict[str, Any]\n    ) -> bool:\n        """\n        –û—Å–≤–æ–±–æ–¥–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n        \n        Args:\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            usage_stats: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è\n            \n        Returns:\n            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–∏\n        """\n        try:\n            logger.info(f"üîì Releasing account {account_id}")\n            \n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.post(\n                    f"{self.base_url}/release/{account_id}",\n                    json={\n                        "service_name": "invite-service",\n                        "usage_stats": usage_stats\n                    }\n                )\n                \n                if response.status_code == 200:\n                    logger.info(f"‚úÖ Account {account_id} released successfully")\n                    return True\n                else:\n                    logger.error(f"‚ùå Failed to release account {account_id}: {response.status_code}")\n                    return False\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error releasing account {account_id}: {e}")\n            return False\n    \n    async def handle_error(\n        self,\n        account_id: str,\n        error_type: str,\n        error_message: str,\n        context: Dict[str, Any] = None\n    ) -> bool:\n        """\n        –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É –∞–∫–∫–∞—É–Ω—Ç–∞\n        \n        Args:\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            error_type: –¢–∏–ø –æ—à–∏–±–∫–∏ (flood_wait, peer_flood, etc.)\n            error_message: –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ\n            context: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n            \n        Returns:\n            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫–∏\n        """\n        try:\n            logger.warning(f"‚ö†Ô∏è Handling error for account {account_id}: {error_type}")\n            \n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.post(\n                    f"{self.base_url}/handle-error/{account_id}",\n                    json={\n                        "error_type": error_type,\n                        "error_message": error_message,\n                        "context": context or {"service": "invite-service"}\n                    }\n                )\n                \n                if response.status_code == 200:\n                    result = response.json()\n                    logger.info(f"‚úÖ Error handled: {result.get('action_taken', 'Unknown action')}")\n                    return True\n                else:\n                    logger.error(f"‚ùå Failed to handle error: {response.status_code}")\n                    return False\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error handling account error: {e}")\n            return False\n    \n    async def check_rate_limit(\n        self,\n        account_id: str,\n        action_type: str = "invite",\n        target_channel_id: Optional[str] = None\n    ) -> Dict[str, Any]:\n        """\n        –ü—Ä–æ–≤–µ—Ä–∏—Ç—å rate limits –ø–µ—Ä–µ–¥ –¥–µ–π—Å—Ç–≤–∏–µ–º\n        \n        Args:\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            action_type: –¢–∏–ø –¥–µ–π—Å—Ç–≤–∏—è (invite, message, add_contact)\n            target_channel_id: ID —Ü–µ–ª–µ–≤–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n            \n        Returns:\n            Dict —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º –ª–∏–º–∏—Ç–æ–≤\n        """\n        try:\n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.post(\n                    f"{self.base_url}/rate-limit/check/{account_id}",\n                    json={\n                        "action_type": action_type,\n                        "target_channel_id": target_channel_id\n                    }\n                )\n                \n                if response.status_code == 200:\n                    return response.json()\n                else:\n                    logger.error(f"‚ùå Failed to check rate limits: {response.status_code}")\n                    return {"allowed": False, "reason": "Rate limit check failed"}\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error checking rate limits: {e}")\n            return {"allowed": False, "reason": f"Error: {e}"}\n    \n    async def record_action(\n        self,\n        account_id: str,\n        action_type: str = "invite",\n        target_channel_id: Optional[str] = None,\n        success: bool = True\n    ) -> bool:\n        """\n        –ó–∞–ø–∏—Å–∞—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ\n        \n        Args:\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            action_type: –¢–∏–ø –¥–µ–π—Å—Ç–≤–∏—è\n            target_channel_id: ID —Ü–µ–ª–µ–≤–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n            success: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –¥–µ–π—Å—Ç–≤–∏—è\n            \n        Returns:\n            bool: –£—Å–ø–µ—à–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏\n        """\n        try:\n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.post(\n                    f"{self.base_url}/rate-limit/record/{account_id}",\n                    json={\n                        "action_type": action_type,\n                        "target_channel_id": target_channel_id,\n                        "success": success\n                    }\n                )\n                \n                return response.status_code == 200\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error recording action: {e}")\n            return False\n    \n    async def get_account_health(self, account_id: str) -> Optional[Dict[str, Any]]:\n        """\n        –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ –∞–∫–∫–∞—É–Ω—Ç–∞\n        \n        Args:\n            account_id: ID –∞–∫–∫–∞—É–Ω—Ç–∞\n            \n        Returns:\n            Dict —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º –∑–¥–æ—Ä–æ–≤—å—è –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ\n        """\n        try:\n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.get(f"{self.base_url}/health/{account_id}")\n                \n                if response.status_code == 200:\n                    return response.json()\n                else:\n                    logger.error(f"‚ùå Failed to check account health: {response.status_code}")\n                    return None\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error checking account health: {e}")\n            return None\n    \n    async def get_recovery_stats(self) -> Optional[Dict[str, Any]]:\n        """\n        –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤\n        \n        Returns:\n            Dict —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ\n        """\n        try:\n            async with httpx.AsyncClient(timeout=self.timeout) as client:\n                response = await client.get(f"{self.base_url}/stats/recovery")\n                \n                if response.status_code == 200:\n                    return response.json()\n                else:\n                    logger.error(f"‚ùå Failed to get recovery stats: {response.status_code}")\n                    return None\n                    \n        except Exception as e:\n            logger.error(f"‚ùå Error getting recovery stats: {e}")\n            return None