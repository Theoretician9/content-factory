# CHECK LIST: Разработка Multi-Platform Parser Service

> **Этот файл — подробный чек-лист разработки мультиплатформенного микросервиса parsing-service. Сервис будет поддерживать парсинг данных из различных социальных платформ (Telegram, Instagram, WhatsApp и др.) через модульную систему адаптеров. Phase 1 фокусируется на Telegram согласно техническому заданию.**

## ЭТАП 1: Подготовка мультиплатформенной архитектуры

### 1.1. Анализ и переработка архитектуры
- [ ] Проанализировать существующий код parsing-service
- [ ] Создать план миграции к мультиплатформенной архитектуре
- [ ] Спроектировать абстрактную систему Platform Adapters
- [ ] Определить универсальные модели данных (platform-agnostic)
- [ ] Спроектировать API endpoints с параметром platform
- [ ] Создать архитектуру plugin-системы для новых платформ

### 1.2. Настройка универсальной базы данных PostgreSQL
- [ ] Создать отдельную БД для parsing-service (parsing_db)
- [ ] Настроить пользователя parsing_user с необходимыми правами
- [ ] Обновить строку подключения в docker-compose.yml
- [ ] Создать универсальные модели SQLAlchemy:
  - [ ] ParseTask (с полем platform: telegram/instagram/whatsapp)
  - [ ] ParseResult (универсальная структура + platform_specific_data JSON)
  - [ ] PlatformChat (обобщенная информация о чатах/группах/страницах)
  - [ ] PlatformUser (унифицированные данные пользователей)
  - [ ] ParseLog (логи с указанием платформы)

### 1.3. Интеграция с RabbitMQ (мультиплатформенные очереди)
- [ ] Настроить Celery для работы с RabbitMQ
- [ ] Создать очереди для разных платформ (telegram_queue, instagram_queue, whatsapp_queue)
- [ ] Создать очереди для разных приоритетов (low, normal, high) для каждой платформы
- [ ] Реализовать универсальную структуру задач:
  - [ ] user_id, link, platform, type, account_id, resume_point, status

### 1.4. Интеграция с Redis (состояния с namespacing)
- [ ] Настроить подключение к Redis для хранения состояний
- [ ] Реализовать класс для управления состояниями задач с platform namespacing
- [ ] Создать систему хранения FloodWait/Rate limit таймеров для всех платформ
- [ ] Настроить TTL для различных типов данных по платформам

## ЭТАП 2: Интеграция с существующими сервисами (мультиплатформенная)

### 2.1. Интеграция с Integration Service (все платформы)
- [ ] Изучить API Integration Service для получения аккаунтов всех платформ
- [ ] Реализовать HTTP клиент для взаимодействия с Integration Service
- [ ] Создать функции для получения аккаунтов с фильтрацией по platform:
  - [ ] Telegram аккаунты (phase 1)
  - [ ] Instagram аккаунты (планируется)
  - [ ] WhatsApp аккаунты (планируется)
- [ ] Реализовать алгоритм выбора оптимального аккаунта с учетом платформы

### 2.2. Интеграция с Vault (мультиплатформенные секреты)
- [ ] Настроить VaultClient с AppRole аутентификацией
- [ ] Реализовать получение секретов для всех платформ:
  - [ ] Telegram .session файлы и api_id/api_hash
  - [ ] Instagram API токены (планируется)
  - [ ] WhatsApp Business API токены (планируется)
- [ ] Создать функции для безопасного создания временных файлов/токенов
- [ ] Настроить пути в Vault: `kv/integrations/{platform}/sessions/{session_id}`

### 2.3. Интеграция с API Gateway (универсальная)
- [ ] Настроить JWT аутентификацию для parsing endpoints
- [ ] Реализовать middleware для извлечения user_id из JWT токена
- [ ] Создать декораторы для проверки прав доступа
- [ ] Добавить валидацию параметра platform в запросах

## ЭТАП 3: Реализация мультиплатформенных API endpoints

### 3.1. Endpoint добавления задач парсинга (универсальный)
- [ ] **POST /parser/queue** - основной endpoint с параметром platform
- [ ] Реализовать Pydantic схемы для валидации:
  - [ ] Универсальная схема ParseTaskCreate с полем platform
  - [ ] Platform-specific валидация (Telegram, Instagram, WhatsApp)
- [ ] Добавить валидацию ссылок для каждой платформы:
  - [ ] Telegram: t.me/username, @username
  - [ ] Instagram: instagram.com/username (планируется)
  - [ ] WhatsApp: wa.me/groupid (планируется)
- [ ] Реализовать автоопределение типа в зависимости от платформы
- [ ] Добавить роутинг задач в соответствующие очереди платформ

### 3.2. Endpoints управления задачами (с фильтрацией по платформе)
- [ ] **GET /parser/tasks?platform=telegram** - список задач с фильтром по платформе
- [ ] **GET /parser/tasks/{task_id}** - информация о конкретной задаче
- [ ] **POST /parser/tasks/{task_id}/pause** - поставить задачу на паузу
- [ ] **POST /parser/tasks/{task_id}/resume** - возобновить задачу
- [ ] **DELETE /parser/tasks/{task_id}** - удалить задачу
- [ ] Добавить фильтрацию по статусу, дате, типу, платформе
- [ ] Реализовать пагинацию для больших списков

### 3.3. Endpoint поиска сообществ (мультиплатформенный)
- [ ] **GET /parser/search?platform=telegram&q=keywords** - поиск с указанием платформы
- [ ] Реализовать параметры: platform, q (query), offset, limit
- [ ] Интегрировать с Platform Adapters:
  - [ ] TelegramAdapter для поиска публичных чатов
  - [ ] InstagramAdapter (планируется)
  - [ ] WhatsAppAdapter (планируется)
- [ ] Унифицированный формат ответа для всех платформ
- [ ] Кэшировать результаты поиска с platform namespacing

### 3.4. Endpoint выгрузки результатов (универсальный)
- [ ] **GET /parser/result/{task_id}?format=json&platform_filter=telegram** - получение результатов
- [ ] Реализовать поддержку форматов: JSON, CSV, NDJSON
- [ ] Создать универсальную структуру данных:
  - [ ] Общие поля: platform, platform_id, username, display_name
  - [ ] Platform-specific поля в JSON объекте
- [ ] Добавить фильтрацию результатов по платформе
- [ ] Реализовать streaming для больших файлов

## ЭТАП 4: Создание системы Platform Adapters (начало с Telegram)

### 4.1. Базовая архитектура Platform Adapters
- [ ] Создать абстрактный базовый класс `BasePlatformAdapter`
- [ ] Определить общие методы: parse(), search(), get_account_info()
- [ ] Реализовать Factory pattern для создания адаптеров
- [ ] Создать систему регистрации новых адаптеров платформ
- [ ] Настроить конфигурацию для каждой платформы

### 4.2. TelegramAdapter - Phase 1 (полная реализация)
- [ ] Установить Telethon в requirements.txt (версия 1.34.0+)
- [ ] Создать класс TelegramAdapter наследующий BasePlatformAdapter
- [ ] Реализовать TelegramClient wrapper с обработкой ошибок
- [ ] Настроить создание клиента из .session файла через Vault

### 4.3. Telegram парсинг групп (iter_participants)
- [ ] Реализовать метод parse_group() в TelegramAdapter
- [ ] Извлекать данные: user_id, username, full_name, language_code, status
- [ ] Добавить получение join_date (если доступно)
- [ ] Реализовать постраничное получение участников
- [ ] Сохранять результаты в универсальном формате

### 4.4. Telegram парсинг каналов (get_messages)
- [ ] Реализовать метод parse_channel() в TelegramAdapter
- [ ] Парсинг сообщений из каналов
- [ ] Получать комментарии к сообщениям (если включены)
- [ ] Извлекать информацию о пользователях-комментаторах
- [ ] Добавить ограничение глубины (10,000 сообщений)

### 4.5. Telegram общая информация и поиск
- [ ] Реализовать метод get_chat_info() для метаданных
- [ ] Обработать различные типы чатов (супергруппы, каналы)
- [ ] Реализовать метод search_communities() для поиска
- [ ] Сохранять информацию в универсальные таблицы с platform='telegram'

### 4.6. Подготовка для будущих адаптеров
- [ ] Создать заглушки InstagramAdapter и WhatsAppAdapter
- [ ] Документировать интерфейс для новых адаптеров
- [ ] Настроить plugin систему для динамической загрузки адаптеров

## ЭТАП 5: Мультиплатформенная обработка ошибок и лимитов

### 5.1. Telegram ошибки (TelegramAdapter)
- [ ] FloodWaitError - сохранение времени ожидания в Redis с namespace 'telegram'
- [ ] SessionExpiredError - пометка сессии как невалидной в Integration Service
- [ ] AuthKeyError - обработка проблем с ключом авторизации
- [ ] ChannelPrivateError - пропуск приватных каналов
- [ ] Rate limiting: 200-300 запросов без задержки, адаптивная пауза
- [ ] Безопасный лимит: 100 сообщений/сек, dynamic backoff

### 5.2. Планируемые ошибки других платформ
- [ ] Instagram API ошибки (InstagramAdapter - планируется)
- [ ] WhatsApp Business API ошибки (WhatsAppAdapter - планируется)
- [ ] Создать универсальную систему классификации ошибок
- [ ] Platform-specific retry стратегии

### 5.3. Универсальная Resume functionality
- [ ] Сохранять offset/cursor/position в Redis с platform namespace
- [ ] Реализовать восстановление с последней позиции для всех платформ
- [ ] Обновлять прогресс задачи в реальном времени
- [ ] Обрабатывать смену аккаунта с сохранением позиции
- [ ] Очистка устаревших resume points

## ЭТАП 6: Мультиплатформенная Celery система

### 6.1. Универсальные Celery задачи
- [ ] Создать основную задачу `parse_platform_content`
- [ ] Реализовать задачи для разных типов и платформ:
  - [ ] `parse_telegram_group/channel`
  - [ ] `parse_instagram_account/posts` (планируется)
  - [ ] `parse_whatsapp_group` (планируется)
- [ ] Добавить retry логику с экспоненциальным backoff
- [ ] Настроить timeout для долго выполняющихся задач

### 6.2. Platform-aware управление аккаунтами
- [ ] Реализовать алгоритм выбора аккаунта с учетом платформы
- [ ] Добавить переключение аккаунтов той же платформы при ban/flood
- [ ] Обновлять статус аккаунта в Integration Service
- [ ] Реализовать queue waiting при отсутствии аккаунтов конкретной платформы
- [ ] Автоматический перезапуск задач при появлении аккаунтов

### 6.3. Мониторинг выполнения (мультиплатформенное)
- [ ] Логировать каждый этап выполнения с указанием платформы
- [ ] Обновлять прогресс в Redis с platform namespacing
- [ ] Сохранять статистику в БД (время, ошибки, платформа)
- [ ] Отправлять метрики в Prometheus с labels по платформам
- [ ] Реализовать webhook уведомления (планируется)

## ЭТАП 7: Мультиплатформенная безопасность и мониторинг

### 7.1. Универсальная безопасность и защита данных
- [ ] Все секреты платформ (.session файлы, API токены) только через Vault API
- [ ] Удаление временных файлов/токенов после использования
- [ ] Шифрование чувствительных данных в БД с platform namespacing
- [ ] Валидация и санитизация входных данных для всех платформ
- [ ] Защита от injection атак
- [ ] Аудит всех действий пользователей с указанием платформы

### 7.2. Мультиплатформенная интеграция с мониторингом
- [ ] Добавить Prometheus метрики с разделением по платформам:
  - [ ] `parse_tasks_active{platform="telegram"}`
  - [ ] `platform_accounts_available{platform="telegram"}`
  - [ ] `platform_accounts_blocked{platform="telegram"}`
  - [ ] `platform_flood_wait_avg{platform="telegram"}`
  - [ ] `platform_fail_rate{platform="telegram"}`
  - [ ] `platform_resume_count{platform="telegram"}`
- [ ] Настроить алерты в Alertmanager с группировкой по платформам
- [ ] Создать Grafana дашборд с разделением метрик по платформам
- [ ] Интегрировать с ELK Stack для централизованного логирования

### 7.3. Platform-specific мониторинг
- [ ] Telegram специфичные метрики и алерты
- [ ] Instagram метрики (планируется)
- [ ] WhatsApp метрики (планируется)
- [ ] Кроссплатформенная аналитика и сравнения

## ЭТАП 8: Мультиплатформенное тестирование

### 8.1. Unit тесты для Platform Adapters
- [ ] Написать тесты для BasePlatformAdapter
- [ ] Тесты для TelegramAdapter с mock Telethon клиентом
- [ ] Тесты для API endpoints с mock данными разных платформ
- [ ] Тесты обработки ошибок для каждой платформы
- [ ] Тесты универсальных схем данных
- [ ] Достичь покрытия кода >80%

### 8.2. Интеграционные тесты (мультиплатформенные)
- [ ] Тесты взаимодействия с Integration Service для всех платформ
- [ ] Тесты работы с Vault (получение секретов разных платформ)
- [ ] Тесты полного цикла для каждой платформы
- [ ] Тесты работы с RabbitMQ очередями разных платформ
- [ ] Тесты восстановления после сбоев
- [ ] Тесты переключения между аккаунтами платформ

### 8.3. Нагрузочное тестирование
- [ ] Тестирование с нагрузкой согласно ТЗ (50 пользователей, 300 аккаунтов)
- [ ] Тестирование смешанной нагрузки (Telegram + будущие платформы)
- [ ] Проверить время отклика API (<500мс)
- [ ] Тестировать стабильность при длительной работе
- [ ] Оптимизировать узкие места производительности

## ЭТАП 9: Production готовность и расширяемость

### 9.1. Подготовка к production
- [ ] Обновить docker-compose.yml для мультиплатформенной архитектуры
- [ ] Настроить health checks для всех компонентов
- [ ] Оптимизировать Dockerfile для production
- [ ] Настроить логротацию с разделением по платформам
- [ ] Подготовить скрипты для деплоя и обновления

### 9.2. Финальное тестирование и валидация
- [ ] Smoke тесты всей мультиплатформенной системы
- [ ] Тестирование интеграции со всеми сервисами
- [ ] Валидация соответствия требованиям мультиплатформенности
- [ ] Тестирование plugin системы для новых платформ
- [ ] Проверка готовности к добавлению Instagram/WhatsApp

### 9.3. Документация и передача
- [ ] Обновить PARSING-SERVICE-PROJECT.md с финальной архитектурой
- [ ] Создать API документацию для всех платформ
- [ ] Написать руководство по добавлению новых платформ
- [ ] Подготовить troubleshooting guide по платформам
- [ ] Документировать Plugin систему

---

## Дополнительные этапы (Phase 2+)

### ЭТАП 10: Instagram Integration (Phase 2)
- [ ] Реализовать InstagramAdapter с Instagram Basic Display API
- [ ] Добавить Instagram-specific endpoints и валидацию
- [ ] Интегрировать Instagram аккаунты через Integration Service

### ЭТАП 11: WhatsApp Integration (Phase 3)
- [ ] Реализовать WhatsAppAdapter с WhatsApp Business API
- [ ] Добавить WhatsApp-specific функционал
- [ ] Тестирование мультиплатформенной системы с 3+ платформами

---

> **Статус проекта**: 🔴 **НЕ НАЧАТ** - Требуется полная переработка под мультиплатформенную архитектуру согласно данному чек-листу. Phase 1 фокусируется на создании универсальной системы Platform Adapters с полной реализацией TelegramAdapter согласно техническому заданию. 