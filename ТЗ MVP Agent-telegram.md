## 1. Назначение и контекст

Этот документ описывает **Техническое Задание на MVP ИИ‑агента для ведения Telegram‑канала**, интегрированного в существующий проект `content-factory`.

- Проект описан в файле `PROJECT`.
- Инфраструктура: Docker Compose, микросервисы, Vault (AppRole), PostgreSQL, Redis, RabbitMQ, Integration Service, Parsing Service, Account Manager, API Gateway.
- Цель MVP — **не демо**, а минимально замкнутая, архитектурно корректная система, которая реально может вести один Telegram‑канал как человек: со стилем, стратегией, памятью и обратной связью.

Дальше по тексту новый сервис будет называться **`evolution-agent`** (микросервис) и будет интегрирован в существующую архитектуру.

---

## 2. Границы MVP и философия

**MVP = глубокий по логике агент, но ограниченный по ширине.**

Сохраняем в MVP:
- **Агентную логику** (Orchestrator, автономные шаги).
- **Память канала** (история постов, реакции, стиль).
- **Стратегию контента** (частота, типы постов, рубрики).
- **Регулярный цикл** (ежедневный контент‑цикл).
- **Обратную связь и корректировку стратегии**.

Осознанно убираем (откладываем):
- Генетическую эволюцию популяций агентов.
- Многократные конкурирующие стратегии.
- Сложные системы голосования моделей.

Но **закладываем интерфейсы и структуры**, чтобы позже можно было добавить эти возможности без переписывания сервиса.

---

## 3. Бизнес‑цель и пользовательский сценарий

### 3.1. Цель

Пользователь SaaS‑платформы (через фронт или API) формирует запрос:

> «Веди Telegram‑канал про X, стиль Y»

Система должна:
1. Проанализировать тему и предполагаемую аудиторию.
2. Сформировать персонажа (persona) канала.
3. Сформировать стратегию контента.
4. Построить календарь публикаций (минимум на 7 дней).
5. Ежедневно генерировать и публиковать посты в Telegram‑канал.
6. Сохранять историю действий и контента.
7. Собирать метрики (просмотры, реакции, комментарии).
8. На основе обратной связи корректировать поведение (микс типов контента и тон).

**Результат:** канал выглядит так, как будто его ведёт **один живой человек** с устойчивым стилем, а не набор разрозненных постов.

---

## 4. Архитектура MVP

### 4.1. Новый микросервис

Создаётся отдельный микросервис:

- Имя: `evolution-agent`.
- Стек:
  - Python 3.11+
  - FastAPI (async)
  - SQLAlchemy (async)
  - Celery + Redis/RabbitMQ
  - Jinja2 (шаблоны промптов)
  - Абстрактный LLM‑клиент с поддержкой нескольких провайдеров (OpenAI, другие внешние/локальные модели)
  - Клиент к Vault (AppRole, общий паттерн как в других сервисах)
  - PostgreSQL (отдельная БД `evolution_db`)
  - (Опционально/расширяемо, но проектируем сразу) Qdrant для векторной памяти

Порт сервиса:
- **Внутренний HTTP порт**: `800X` (нужно подобрать свободный порт, не конфликтующий с `integration-service`, `invite-service` и `parsing-service` — например, `8004`).
- Доступ только из `backend`‑сети Docker.
- Внешний доступ — только через `api-gateway`.

### 4.2. Логические компоненты внутри сервиса

1. **Orchestrator (ядро)**  
   - Управляет жизненным циклом задач.
   - Хранит и обновляет `TaskRuntimeContext`.
   - Инициирует шаги Research / Content.
   - Принимает решения при ошибках и ретраях.

2. **Prompt Engine (Prompt Generator, без ML)**  
   - Шаблонизатор на Jinja2 + YAML/JSON конфиги.
   - Версионирование шаблонов промптов.
   - Сборка system‑prompt’ов и контекста для LLM.

3. **Research Agent**  
   - Собирает контекст: тематика, новости, конкуренты.
   - Использует `parsing-service` и/или веб‑источники (по мере появления).
   - Преобразует данные в структурированный `research_context`.

4. **Content Agent**  
   - На основе стратегии, персоны, `research_context` и истории создаёт тексты постов.
   - Строго следует ограничениям (длина, запреты, стиль).

5. **Memory & Feedback Manager**  
   - Хранит историю постов, стратегий и метрик в PostgreSQL.
   - (По возможности) использует Qdrant для векторных представлений стиля и удачных формулировок.
   - Обновляет стратегию на основе фидбека.

6. **Scheduler (Celery beat + Celery workers)**  
   - Планирует выполнение генерации по `calendar_slots`.
   - Запускает пайплайн генерации и публикации.

7. **Integration Clients**  
   - HTTP‑клиент к `integration-service` и его Account Manager для работы с Telegram‑аккаунтами (подключение, аллокация/освобождение, получение сессий, передача статистики).
   - HTTP‑клиент к `parsing-service` для получения данных.
   - Клиент к Vault для LLM‑ключей и настроек БД.

8. **Telegram Posting Subsystem** (внутренний модуль `evolution-agent`)  
   - Отвечает **исключительно за отправку сообщений/постов в Telegram**.
   - НЕ расширяет функциональность `integration-service` и НЕ дублирует Account Manager.
   - Использует:
     - аллокацию/освобождение аккаунтов через Account Manager Integration Service;
     - сессионные данные (StringSession и пр.), получаемые по защищённому API `integration-service`;
     - собственный Telegram‑клиент (Telethon или аналог) для фактической отправки сообщений.
   - Соблюдение лимитов и восстановление после ошибок реализуются через существующий Account Manager:
     - перед отправкой поста запрашивается аккаунт;
     - после отправки/ошибки результаты и ошибки репортятся обратно в Account Manager.

---

## 5. Интеграция с существующим проектом

### 5.1. Авторизация и API Gateway

- Внешний пользователь обращается к `evolution-agent` **только через `api-gateway`**.
- Авторизация — через существующую JWT‑схему:
  - `sub` = email пользователя.
  - Внутри `evolution-agent` email конвертируется в `user_id` через API Gateway (тот же паттерн, что в других сервисах).
- Все методы `evolution-agent` должны:
  - Принимать JWT из заголовка `Authorization: Bearer ...`.
  - Извлекать `user_id` и фильтровать данные только по нему.

### 5.2. Связь с Integration Service

Используем уже существующую Telegram‑инфраструктуру из `integration-service`:

- Там уже реализованы:
  - Подключение Telegram‑аккаунтов (SMS/QR, 2FA).
  - Хранение и шифрование сессий.
  - Ограничения и безопасность.

Для отправки сообщений в канал требуется:
- **Определённый REST‑эндпоинт в `integration-service`** (если его ещё нет, он является частью работ по ТЗ):
  - `POST /api/v1/telegram/messages/send`
  - Тело:
    ```json
    {
      "channel_id": "telegram_channel_id_or_link",
      "session_id": "uuid-сессии-аккаунта",
      "text": "Markdown текст поста",
      "parse_mode": "markdown"
    }
    ```
  - Ответ:
    ```json
    {
      "telegram_message_id": 123,
      "sent_at": "2025-01-01T12:00:00Z"
    }
    ```
  - Обработка:
    - Ошибки Telegram (FloodWait, блокировки) конвертируются в нормализованные коды/типы.
    - При ошибках типа FloodWait `evolution-agent` должен уметь делать retry с backoff.

### 5.3. Связь с Parsing Service

`parsing-service` уже умеет:
- Создавать задачи парсинга Telegram каналов/групп.
- Хранить результаты в своей БД.

Для MVP `evolution-agent` определяет простой контракт:

- Новый внутренний эндпоинт в `parsing-service` (если нет):
  - `POST /internal/research/search`
  - Тело:
    ```json
    {
      "topic": "crypto investments",
      "limit": 20
    }
    ```
  - Ответ:
    ```json
    {
      "items": [
        {
          "source": "telegram_channel",
          "channel": "@example",
          "text": "сообщение...",
          "ts": "2025-01-01T12:00:00Z"
        }
      ]
    }
    ```
- Внутри `parsing-service` это может быть либо реальный запрос к уже собранным данным, либо постановка и ожидание завершения задач парсинга. Детали реализации решаются там, но контракт для `evolution-agent` должен быть стабильным.

### 5.4. Vault и секреты

`evolution-agent` использует общий паттерн Vault AppRole:

- Переменные окружения:
  - `VAULT_ADDR`
  - `VAULT_ROLE_ID`
  - `VAULT_SECRET_ID`
- Секреты в Vault:
  - `kv/data/openai`:
    - `api_key`: OpenAI API key (для GPT‑4o).
  - `kv/data/evolution-agent/db`:
    - `database_url`: строка подключения `postgresql+asyncpg://.../evolution_db`.
- При старте сервиса:
  - `ServiceVaultClient` получает токен через AppRole.
  - Читает секреты, инициализирует OpenAI client и подключение к БД.

### 5.5. Базы данных и хранилища

- **PostgreSQL**:
  - Отдельная БД `evolution_db`.
  - Схема описана ниже.
- **Redis**:
  - Используется как broker/backend Celery, а также для:
    - блокировок (distributed locks по `calendar_slot_id` / `channel_id`);
    - краткосрочного кэша состояний задач.
- **Qdrant (опционально, но рекомендуется)**:
  - Отдельный контейнер в docker-compose.
  - Используется для хранения векторных представлений:
    - стиля канала;
    - удачных постов;
    - типичных формулировок CTA.

---

## 6. Модель данных (PostgreSQL `evolution_db`)

Все таблицы реализуются через async SQLAlchemy + Alembic миграции.

### 6.1. `strategies` — стратегия канала

- `id` (UUID, PK)
- `user_id` (int, FK на общую систему пользователей через API Gateway, логически)
- `channel_id` (text) — идентификатор Telegram‑канала (username или id).
- `version` (int) — версия стратегии.
- `persona_json` (JSONB) — описывает персону:
  - тон, словарь, допустимый уровень шуток/иронии;
  - запрещённые темы и слова;
  - уровень формальности.
- `content_mix_json` (JSONB) — веса рубрик:
  - например: `{"education": 0.5, "opinion": 0.3, "news": 0.2}`.
- `schedule_rules_json` (JSONB) — частота, предпочтительные часы и дни.
- `is_active` (bool)
- `created_at` (timestamptz)

Ограничение: для `(user_id, channel_id)` одновременно активна только одна стратегия (`is_active = true`).

### 6.2. `calendar_slots` — контент‑план

- `id` (UUID, PK)
- `user_id` (int)
- `channel_id` (text)
- `strategy_id` (UUID, FK `strategies.id`)
- `dt` (timestamptz) — запланированное время публикации (UTC).
- `status` (enum: `planned`, `processing`, `ready`, `published`, `failed`)
- `pillar` (text) — рубрика/тема слота (например, "Market Analysis").
- `locked_by` (text, nullable) — id Celery‑задачи, которая обрабатывает слот.
- `created_at` (timestamptz)
- `updated_at` (timestamptz)

Вторичный индекс: `(user_id, channel_id, dt)`.

### 6.3. `posts` — сгенерированные посты

- `id` (UUID, PK)
- `user_id` (int)
- `channel_id` (text)
- `slot_id` (UUID, FK на `calendar_slots.id`, unique)
- `content_text` (text) — финальный текст (Markdown).
- `hashtags` (JSONB) — массив строк.
- `cta` (text, nullable) — призыв к действию.
- `meta_stats` (JSONB) — технические данные:
  - модель, токены, время генерации и т.п.
- `telegram_message_id` (bigint, nullable) — id сообщения в Telegram после публикации.
- `created_at` (timestamptz)

### 6.4. `memory_logs` — обратная связь

- `id` (UUID, PK)
- `user_id` (int)
- `channel_id` (text)
- `post_id` (UUID, FK `posts.id`)
- `metrics_snapshot` (JSONB):
  - `views`, `reactions`, `comments_count`, `sentiment` и т.п.
- `collected_at` (timestamptz)

### 6.5. `agent_tasks` — задачи оркестратора (опционально)

- `task_id` (UUID, PK)
- `user_id` (int)
- `channel_id` (text)
- `slot_id` (UUID, nullable) — если задача привязана к слоту.
- `status` (enum: `created`, `running`, `completed`, `failed`)
- `goal` (text) — например: `manage_telegram_channel`.
- `user_request` (text) — исходный запрос пользователя.
- `created_at`, `updated_at` (timestamptz)

---

## 7. TaskRuntimeContext и оперативное состояние

### 7.1. Структура `TaskRuntimeContext`

Объект существует в двух формах:
- В Redis (оперативное состояние во время выполнения).
- В PostgreSQL (снапшоты и логирование).

Пример структуры (Pydantic‑модель):

```python
class TaskRuntimeContext(BaseModel):
    task_id: UUID
    user_id: int
    channel_id: str
    slot_id: UUID
    current_step: str  # init / research / draft / validate / publish / done / error
    persona: dict | None = None
    strategy_snapshot: dict | None = None
    research_data: list[dict] = []
    insights: list[str] = []
    draft_content: str | None = None
    errors: list[str] = []
    decisions_log: list[str] = []
```

### 7.2. Принципы

- **Никаких сырых пользовательских данных напрямую в LLM**:
  - Всё сначала нормализуется и упаковывается в структуру.
- Каждый шаг пайплайна **идемпотентен**:
  - Повторный запуск шага при падении не должен ломать состояние или дублировать данные.
- Все изменения состояния фиксируются в `decisions_log`.

---

## 8. Нормализация пользовательского запроса и формирование Persona

### 8.1. Нормализация запроса (rule‑based, без ML)

После вызова `POST /api/v1/agents/onboard` (см. ниже) Orchestrator:

1. Очищает текст: убирает лишние пробелы, HTML, переносы строк.
2. Определяет язык (простая эвристика по алфавиту / ключевым словам, без внешнего ML).
3. Извлекает intent и подсказки стиля:
   - ключевые слова: «вести канал», «стиль», «аудитория» и т.п.
4. Формирует нормализованный объект:
   ```json
   {
     "topic": "инвестиции в криптовалюту",
     "style_hint": "спокойный, аналитический",
     "audience_hint": "частные инвесторы"
   }
   ```

### 8.2. Persona (персона канала)

Persona формируется **детерминированно**:

- На основе:
  - нормализованного запроса;
  - пресетов в YAML (`persona_presets.yaml`);
  - ограничений Telegram;
  - общих правил безопасности проекта.

Пример пресета:

```yaml
crypto_analyst:
  tone: calm
  vocabulary: professional
  risk_profile: conservative
  forbidden_topics:
    - гарантированная прибыль
    - инсайдерская информация
```

Алгоритм:
1. Выбрать ближайший пресет по теме/ключевым словам.
2. Наложить hint’ы пользователя (например, усилить «иронию» или наоборот, формальность).
3. Сохранить результат в `strategies.persona_json`.

---

## 9. Prompt Engine (Prompt Generator, без ML)

### 9.1. Компоненты

1. **PromptTemplateRegistry**  
   - Хранит версионируемые шаблоны промптов (YAML/Jinja2).
   - Например: `research_agent_v1`, `content_agent_v1`.

2. **PromptAssembler**  
   - Собирает:
     - `system`‑часть;
     - `context`‑часть (persona, strategy, slot pillar);
     - `memory`‑часть (фрагменты прошлых удачных постов/результатов).

3. **ConstraintInjector**  
   - Добавляет ограничения:
     - лимиты длины текста;
     - запрет тем;
     - формат вывода (строгий JSON).

### 9.2. Пример шаблона для Content Agent

Файл `templates/content_writer_v1.j2`:

```text
You are a {{ persona.tone }} Telegram channel author.
Your audience: {{ strategy.audience_desc }}.
Current topic: {{ pillar }}.

SOURCE DATA:
{% for item in insights %}
- {{ item }}
{% endfor %}

CONSTRAINTS:
- Max length: {{ strategy.max_chars }} characters.
- Forbidden topics: {{ persona.forbidden_topics | join(', ') }}.
- Language: {{ strategy.language }}.

REQUIREMENTS:
- Return strict JSON: {"post_text": "...", "hashtags": [], "cta": "..."}.
```

---

## 10. Research Agent — логика

### 10.1. Когда вызывается

- При первичном онбординге канала (создание стратегии).
- Периодически (например, раз в неделю) для обновления контекстов.
- При генерации каждого слота — может использовать как свежие данные, так и кэш.

### 10.2. Вход

- Нормализованный запрос (topic, style_hint, audience_hint).
- Persona/strategy snapshot.
- Информация о `pillar` слота.

### 10.3. Шаги

1. Собрать сырые данные:
   - Запрос к `parsing-service` по теме/каналу.
2. Нормализовать в унифицированный формат:
   ```json
   {
     "items": [
       { "source": "telegram_channel", "text": "...", "ts": "..." }
     ]
   }
   ```
3. Сформировать промпт для GPT‑4o (через Prompt Engine) для извлечения инсайтов:
   - Какие темы заходят;
   - Типы форматов;
   - Частота CTA;
   - Часто используемые формулировки.
4. Сохранить `insights` в `TaskRuntimeContext` и по необходимости в долгосрочную память.

---

## 11. Content Agent — логика

### 11.1. Назначение

- Сгенерировать текст поста, который:
  - соответствует персоне и стратегии;
  - учитывает свежие `insights` и прошлый опыт;
  - соблюдает ограничения Telegram и проекта.

### 11.2. Вход

- Persona snapshot.
- Strategy snapshot.
- `pillar` текущего слота.
- `insights` из Research Agent.
- Несколько прошлых успешных постов (из БД/векторного поиска).

### 11.3. Шаги

1. Собрать полный промпт через Prompt Engine.
2. Вызвать GPT‑4o:
   - Модель: `gpt-4o`.
   - Формат вывода: строгий JSON (`post_text`, `hashtags`, `cta`).
3. Распарсить ответ, записать в `TaskRuntimeContext.draft_content` и далее в таблицу `posts` после валидации.

---

## 12. Ежедневный контент‑цикл (основной пайплайн)

Celery‑задача: `run_slot_generation(slot_id)`.

### 12.1. Алгоритм

1. **Load & Lock**
   - Найти слот `calendar_slots.id = slot_id`.
   - Проверить статус: если не `planned` — завершить.
   - Поставить статус `processing`, записать `locked_by` (id задачи).
   - Записать в Redis lock по `slot_id` (чтобы не запустить параллельно).

2. **Инициализация контекста**
   - Загрузить активную стратегию и персону.
   - Инициализировать `TaskRuntimeContext`.

3. **Research**
   - Вызвать Research Agent.
   - Заполнить `research_data` и `insights` в контексте.

4. **Drafting (Content Agent)**
   - Вызвать GPT‑4o для генерации черновика.

5. **Quality Gate (валидация без ML)**
   - Проверить длину.
   - Проверить на запрещённые темы/слова.
   - Проверить отсутствие грубых повторов последних N постов.
   - При нарушении — до 3 попыток повторной генерации с усиленными ограничениями.

6. **Сохранение**
   - Создать запись в `posts` с текстом и метаданными.
   - Обновить `calendar_slots.status` на `ready`.

7. **Публикация**
   - Если время слота уже наступило (или в пределах X минут):
     - Вызвать `integration-service` для отправки сообщения.
     - Сохранить `telegram_message_id`.
     - Обновить `calendar_slots.status` на `published`.
   - Иначе — оставить статус `ready`, а публикацию выполнять отдельной задачей ближе ко времени.

8. **Разблокировка**
   - Очистить lock в Redis.
   - Обновить `TaskRuntimeContext` как завершённый.

---

## 13. Обратная связь и адаптация стратегии

### 13.1. Сбор метрик

Для каждого опубликованного поста периодически (например, раз в сутки) запускается задача:

- Получить метрики через существующие механизмы (по мере их реализации в Integration/Parsing или другом сервисе, либо временно через Telegram API, проксированный через Integration Service).
- Записать в `memory_logs.metrics_snapshot`.

### 13.2. Адаптация

Простая rule‑based таблица решений:

- Если `engagement` (реакции/просмотры) ниже порога:
  - увеличить долю образовательного контента;
  - уменьшить агрессивность CTA.
- Если много негативных комментариев:
  - смягчить тон.

Изменения записываются в новую версию `strategies` (версионирование), при этом старая версия остаётся для анализа.

---

## 14. API `evolution-agent` (FastAPI)

Все эндпоинты — под префиксом `/api/v1/agents`, доступны только через `api-gateway` и только с JWT.

### 14.1. `POST /api/v1/agents/onboard`

**Назначение:** инициализация агента для конкретного пользователя и канала.

Вход:
```json
{
  "channel_id": "telegram_username_or_id",
  "description": "Веди канал про бизнес для малого предпринимателя",
  "tone": "дружелюбный, экспертный",
  "language": "ru"
}
```

Логика:
1. Получить `user_id` из JWT.
2. Нормализовать запрос.
3. Сформировать `persona`.
4. Создать `strategies` (версия 1, `is_active = true`).
5. Сгенерировать `calendar_slots` минимум на 7 дней вперёд (частота из `schedule_rules_json`).
6. Вернуть пользователю информацию о созданной стратегии и календаре.

### 14.2. `GET /api/v1/agents/calendar`

**Назначение:** получить контент‑план для пользователя.

Параметры:
- `channel_id` (optional) — фильтр по каналу.

Ответ:
```json
[
  {
    "slot_id": "uuid",
    "dt": "2025-01-01T12:00:00Z",
    "pillar": "Market Analysis",
    "status": "planned"
  }
]
```

### 14.3. `POST /api/v1/agents/slots/{slot_id}/regenerate`

**Назначение:** вручную перегенерировать пост для слота с пользовательским фидбеком.

Вход:
```json
{
  "feedback": "Сделать короче и менее формально"
}
```

Логика:
- Создать новую Celery‑задачу `run_slot_generation` с дополнительным ограничением/подсказкой.

### 14.4. `POST /api/v1/agents/force-run`

**Назначение:** принудительный запуск пайплайна (для отладки/админки).

Вход:
```json
{
  "channel_id": "telegram_username_or_id",
  "from": "2025-01-01T00:00:00Z",
  "to": "2025-01-02T00:00:00Z"
}
```

Логика:
- Найти все слоты в интервале для пользователя/канала и запустить генерацию.

---

## 15. Нефункциональные требования

- **Latency**:
  - Генерация одного поста (без учёта очереди) — не более 5–7 секунд при нормальной загрузке.
- **Надёжность**:
  - Все шаги пайплайна — идемпотентны.
  - Celery‑задачи используют retry с exponential backoff при сетевых ошибках/429.
- **Безопасность**:
  - Все секреты только в Vault.
  - JWT проверяется в каждом запросе; пользователь видит только свои данные.
  - Логи содержат только технические детали без секретов и без текстов JWT.
- **Логирование**:
  - JSON‑логгер, совместимый с ELK.
  - Каждому запросу и задаче назначается `trace_id`.
  - Логируются ключевые события: старт/финиш Research, LLM‑запросы, публикация, ошибки.

---

## 16. Критерии готовности MVP

MVP считается готовым, если выполняются все условия:

1. Пользователь может через фронт/API:
   - создать агента для своего Telegram‑канала;
   - увидеть сгенерированный контент‑план;
   - просматривать сгенерированные и опубликованные посты.
2. Система:
   - ежедневно генерирует и публикует посты по календарю;
   - использует историю и фидбек для корректировки стратегии;
   - корректно обрабатывает ошибки Telegram и внешних сервисов без падения всей системы.
3. Новый сервис:
   - полностью вписан в архитектуру проекта `content-factory` (Vault, Docker‑сети, API Gateway, логирование, мониторинг);
   - не содержит заглушек вместо реальных HTTP‑клиентов к Integration/Parsing/OpenAI;
   - готов к добавлению новых стратегий, экспериментального multi‑agent и DAG‑оркестрации без слома текущих интерфейсов.

